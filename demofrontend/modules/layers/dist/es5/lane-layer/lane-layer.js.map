{"version":3,"sources":["../../../src/lane-layer/lane-layer.js"],"names":["defaultProps","PathLayer","highPrecisionDash","getColor2","type","value","getWidth","getDashArray2","LaneLayer","shaders","vs","replace","inject","context","getAttributeManager","addInstanced","instanceStrokeWidths","size","accessor","defaultValue","instanceColors2","props","colorFormat","length","GL","UNSIGNED_BYTE","normalized","instanceStartRatio","update","calculateStartRatios","instanceDashArrays","instanceDashArrays2","params","model","state","attributes","getAttributes","setUniforms","strokeIndex","setAttributes","instanceColors","dashAlignMode","dashJustified","draw","attribute","constant","Float32Array","numInstances","viewport","positions","instanceTypes","target","startPoint","Vector3","endPoint","totalLength","i","set","copy","projectPosition","segmentLength","distance","layerName"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAoBA;;AACA;;AACA;;;;;;;;;;AAEA,IAAMA,YAAY,mCACbC,kBAAUD,YADG;AAGhBE,EAAAA,iBAAiB,EAAE,KAHH;AAKhBC,EAAAA,SAAS,EAAE;AAACC,IAAAA,IAAI,EAAE,UAAP;AAAmBC,IAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,GAAV;AAA1B,GALK;AAMhBC,EAAAA,QAAQ,EAAE;AAACF,IAAAA,IAAI,EAAE,UAAP;AAAmBC,IAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;AAA1B,GANM;AAOhBE,EAAAA,aAAa,EAAE;AAACH,IAAAA,IAAI,EAAE,UAAP;AAAmBC,IAAAA,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ;AAA1B;AAPC,EAAlB;;IAUqBG,S;;;;;;;;;;;;iCACN;AACX,UAAMC,OAAO,8GAAb;AAEAA,MAAAA,OAAO,CAACC,EAAR,GAAaD,OAAO,CAACC,EAAR,CACVC,OADU,CACF,sCADE,EACsC,qCADtC,EAEVA,OAFU,CAGT,mCAHS,EAIT,yFAJS,CAAb;AAOAF,MAAAA,OAAO,CAACG,MAAR,GAAiB;AACf,6MADe;AAYf,ocAZe;AA0Bf,kTA1Be;AAkDf;AAlDe,OAAjB;AA6EA,aAAOH,OAAP;AACD;;;oCAEeI,O,EAAS;AACvB,uHAAsBA,OAAtB;AAEA,WAAKC,mBAAL,GAA2BC,YAA3B,CAAwC;AACtCC,QAAAA,oBAAoB,EAAE;AACpBC,UAAAA,IAAI,EAAE,CADc;AAEpBC,UAAAA,QAAQ,EAAE,UAFU;AAGpBC,UAAAA,YAAY,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;AAHM,SADgB;AAMtCC,QAAAA,eAAe,EAAE;AACfH,UAAAA,IAAI,EAAE,KAAKI,KAAL,CAAWC,WAAX,CAAuBC,MADd;AAEfnB,UAAAA,IAAI,EAAEoB,sBAAGC,aAFM;AAGfC,UAAAA,UAAU,EAAE,IAHG;AAIfR,UAAAA,QAAQ,EAAE,WAJK;AAKfC,UAAAA,YAAY,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,GAAV;AALC,SANqB;AAatCQ,QAAAA,kBAAkB,EAAE;AAClBV,UAAAA,IAAI,EAAE,CADY;AAElBW,UAAAA,MAAM,EAAE,KAAKC;AAFK,SAbkB;AAiBtCC,QAAAA,kBAAkB,EAAE;AAACb,UAAAA,IAAI,EAAE,CAAP;AAAUC,UAAAA,QAAQ,EAAE;AAApB,SAjBkB;AAkBtCa,QAAAA,mBAAmB,EAAE;AAACd,UAAAA,IAAI,EAAE,CAAP;AAAUC,UAAAA,QAAQ,EAAE;AAApB;AAlBiB,OAAxC;AAoBD;;;yBAEIc,M,EAAQ;AAAA,UACJC,KADI,GACK,KAAKC,KADV,CACJD,KADI;AAEX,UAAME,UAAU,GAAG,KAAKrB,mBAAL,GAA2BsB,aAA3B,EAAnB;AACAH,MAAAA,KAAK,CAACI,WAAN,CAAkB;AAChBC,QAAAA,WAAW,EAAE;AADG,OAAlB;AAGAL,MAAAA,KAAK,CAACM,aAAN,CAAoB;AAClBC,QAAAA,cAAc,EAAEL,UAAU,CAACK,cADT;AAElBV,QAAAA,kBAAkB,EAAEK,UAAU,CAACL;AAFb,OAApB;AAIA,4GAAWE,MAAX;AAEAC,MAAAA,KAAK,CAACI,WAAN,CAAkB;AAChBC,QAAAA,WAAW,EAAE,CADG;AAEhBG,QAAAA,aAAa,EAAE,KAAKpB,KAAL,CAAWqB,aAAX,GAA2B,CAA3B,GAA+B;AAF9B,OAAlB;AAIAT,MAAAA,KAAK,CAACM,aAAN,CAAoB;AAClBC,QAAAA,cAAc,EAAEL,UAAU,CAACf,eADT;AAElBU,QAAAA,kBAAkB,EAAEK,UAAU,CAACJ;AAFb,OAApB;AAIAE,MAAAA,KAAK,CAACU,IAAN;AACD;;;yCAEoBC,S,EAAW;AAC9B,UAAI,CAAC,KAAKvB,KAAL,CAAWnB,iBAAhB,EAAmC;AACjC0C,QAAAA,SAAS,CAACC,QAAV,GAAqB,IAArB;AACAD,QAAAA,SAAS,CAACvC,KAAV,GAAkB,IAAIyC,YAAJ,CAAiB,CAAjB,CAAlB;AACA;AACD;;AAL6B,UAOvBC,YAPuB,GAOP,KAAKb,KAPE,CAOvBa,YAPuB;AAAA,UAQvBC,QARuB,GAQX,KAAKnC,OARM,CAQvBmC,QARuB;;AAAA,kCAUG,KAAKlC,mBAAL,GAA2BsB,aAA3B,EAVH;AAAA,UAUzBa,SAVyB,yBAUzBA,SAVyB;AAAA,UAUdC,aAVc,yBAUdA,aAVc;;AAW9BD,MAAAA,SAAS,GAAGA,SAAS,CAAC5C,KAAtB;AACA6C,MAAAA,aAAa,GAAGA,aAAa,CAAC7C,KAA9B;AAEA,UAAM8C,MAAM,GAAGP,SAAS,CAACvC,KAAzB;AAEA,UAAM+C,UAAU,GAAG,IAAIC,aAAJ,EAAnB;AACA,UAAMC,QAAQ,GAAG,IAAID,aAAJ,EAAjB;AACA,UAAIE,WAAW,GAAG,CAAlB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,YAAY,GAAG,CAAnC,EAAsCS,CAAC,EAAvC,EAA2C;AACzCJ,QAAAA,UAAU,CAACK,GAAX,CAAeR,SAAS,CAACO,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAxB,EAAqCP,SAAS,CAACO,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA9C,EAA2DP,SAAS,CAACO,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAApE;AAEAF,QAAAA,QAAQ,CAACG,GAAT,CAAaR,SAAS,CAACO,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAtB,EAAmCP,SAAS,CAACO,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAA5C,EAAyDP,SAAS,CAACO,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAlE;AAEAJ,QAAAA,UAAU,CAACM,IAAX,CAAgBV,QAAQ,CAACW,eAAT,CAAyBP,UAAzB,CAAhB;AACAE,QAAAA,QAAQ,CAACI,IAAT,CAAcV,QAAQ,CAACW,eAAT,CAAyBL,QAAzB,CAAd;AAEA,YAAMM,aAAa,GAAGR,UAAU,CAACS,QAAX,CAAoBP,QAApB,CAAtB;AAEAH,QAAAA,MAAM,CAACK,CAAD,CAAN,GAAYI,aAAa,GAAGL,WAAW,GAAGK,aAAjB,GAAiC,CAA1D;;AAEA,YAAIV,aAAa,CAACM,CAAD,CAAb,IAAoB,CAAxB,EAA2B;AACzBD,UAAAA,WAAW,IAAIK,aAAf;AACD,SAFD,MAEO;AACLL,UAAAA,WAAW,GAAG,CAAd;AACD;AACF;AACF;;;EAjLoCtD,iB;;;AAoLvCO,SAAS,CAACsD,SAAV,GAAsB,WAAtB;AACAtD,SAAS,CAACR,YAAV,GAAyBA,YAAzB","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {PathLayer} from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport {Vector3} from 'math.gl';\n\nconst defaultProps = {\n  ...PathLayer.defaultProps,\n\n  highPrecisionDash: false,\n\n  getColor2: {type: 'accessor', value: [0, 0, 0, 255]},\n  getWidth: {type: 'accessor', value: [1, 0, 0]},\n  getDashArray2: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class LaneLayer extends PathLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n\n    shaders.vs = shaders.vs\n      .replace('attribute float instanceStrokeWidths', 'attribute vec3 instanceStrokeWidths')\n      .replace(\n        'instanceStrokeWidths * widthScale',\n        '(instanceStrokeWidths.x + instanceStrokeWidths.y + instanceStrokeWidths.z) * widthScale'\n      );\n\n    shaders.inject = {\n      'vs:#decl': `\nuniform float strokeIndex;\n\nattribute vec4 instanceDashArrays;\nattribute float instanceStartRatio;\n\nvarying vec4 vDashArray;\nvarying vec2 vWidth;\nvarying float vPathOffset;\n`,\n\n      'vs:#main-end': `\n  vDashArray = instanceDashArrays;\n\n  float totalWidth = instanceStrokeWidths.x + instanceStrokeWidths.y + instanceStrokeWidths.z;\n  if (strokeIndex == 0.0) {\n    vWidth = vec2(0.0, instanceStrokeWidths.x / totalWidth);\n  } else {\n    vWidth = vec2(1.0 - instanceStrokeWidths.z / totalWidth, 1.0);\n  }\n  // map to [-1.0, 1.0] space\n  vWidth = 1.0 - vWidth * 2.0;\n  vPathOffset = vPathLength * instanceStartRatio;\n`,\n\n      'fs:#decl': `\nuniform float dashAlignMode;\nvarying vec4 vDashArray;\nvarying vec2 vWidth;\nvarying float vPathOffset;\n\n// mod doesn't work correctly for negative numbers\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n`,\n\n      // if given position is in the gap part of the dashed line\n      // dashArray.x: solid stroke length, relative to width\n      // dashArray.y: gap length, relative to width\n      // alignMode:\n      // 0 - no adjustment\n      // o----     ----     ----     ---- o----     -o----     ----     o\n      // 1 - stretch to fit, draw half dash at each end for nicer joints\n      // o--    ----    ----    ----    --o--      --o--     ----     --o\n      'fs:#main-start': `\n  if (vPathPosition.x > vWidth.x || vPathPosition.x < vWidth.y) {\n    discard;\n  }\n\n  float solid1 = vDashArray.x;\n  float gap1 = solid1 + vDashArray.y;\n  float solid2 = gap1 + vDashArray.z;\n  float unitLength = solid2 + vDashArray.w;\n\n  if (unitLength > 0.0 && vDashArray.y > 0.0) {\n    unitLength = mix(\n      unitLength,\n      vPathLength / round(vPathLength / unitLength),\n      dashAlignMode\n    );\n\n    float offset = mix(vPathOffset, vDashArray.x / 2.0, dashAlignMode);\n    float unitPosition = mod2(vPathPosition.y + offset, unitLength);\n\n    if (unitPosition > solid1 && unitPosition < gap1 || unitPosition > solid2) {\n      discard;\n    }\n  }\n`\n    };\n\n    return shaders;\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    this.getAttributeManager().addInstanced({\n      instanceStrokeWidths: {\n        size: 3,\n        accessor: 'getWidth',\n        defaultValue: [1, 0, 0]\n      },\n      instanceColors2: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        accessor: 'getColor2',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceStartRatio: {\n        size: 1,\n        update: this.calculateStartRatios\n      },\n      instanceDashArrays: {size: 4, accessor: 'getDashArray'},\n      instanceDashArrays2: {size: 4, accessor: 'getDashArray2'}\n    });\n  }\n\n  draw(params) {\n    const {model} = this.state;\n    const attributes = this.getAttributeManager().getAttributes();\n    model.setUniforms({\n      strokeIndex: 0\n    });\n    model.setAttributes({\n      instanceColors: attributes.instanceColors,\n      instanceDashArrays: attributes.instanceDashArrays\n    });\n    super.draw(params);\n\n    model.setUniforms({\n      strokeIndex: 1,\n      dashAlignMode: this.props.dashJustified ? 1 : 0\n    });\n    model.setAttributes({\n      instanceColors: attributes.instanceColors2,\n      instanceDashArrays: attributes.instanceDashArrays2\n    });\n    model.draw();\n  }\n\n  calculateStartRatios(attribute) {\n    if (!this.props.highPrecisionDash) {\n      attribute.constant = true;\n      attribute.value = new Float32Array(1);\n      return;\n    }\n\n    const {numInstances} = this.state;\n    const {viewport} = this.context;\n\n    let {positions, instanceTypes} = this.getAttributeManager().getAttributes();\n    positions = positions.value;\n    instanceTypes = instanceTypes.value;\n\n    const target = attribute.value;\n\n    const startPoint = new Vector3();\n    const endPoint = new Vector3();\n    let totalLength = 0;\n\n    for (let i = 0; i < numInstances - 1; i++) {\n      startPoint.set(positions[i * 3 + 0], positions[i * 3 + 1], positions[i * 3 + 2]);\n\n      endPoint.set(positions[i * 3 + 3], positions[i * 3 + 4], positions[i * 3 + 5]);\n\n      startPoint.copy(viewport.projectPosition(startPoint));\n      endPoint.copy(viewport.projectPosition(endPoint));\n\n      const segmentLength = startPoint.distance(endPoint);\n\n      target[i] = segmentLength ? totalLength / segmentLength : 0;\n\n      if (instanceTypes[i] <= 1) {\n        totalLength += segmentLength;\n      } else {\n        totalLength = 0;\n      }\n    }\n  }\n}\n\nLaneLayer.layerName = 'LaneLayer';\nLaneLayer.defaultProps = defaultProps;\n"],"file":"lane-layer.js"}