{"version":3,"sources":["../../../src/loaders/xviz-websocket-loader.js"],"names":["XVIZWebsocketLoader","options","xvizHandler","XVIZController","socket","_debug","requestParams","_onOpen","event","retrySettings","retries","minTimeout","randomize","streamBuffer","XVIZStreamBuffer","WebSocketClass","WebSocket","timestamp","url","retry","Promise","resolve","reject","ws","binaryType","onmessage","message","hasMetadata","Boolean","getMetadata","data","onResult","onXVIZMessage","onError","debug","bind","worker","maxConcurrency","onerror","onclose","_onWSClose","onopen","_onWSOpen","err","_onWSError","isAbnormalClosure","code","close","Error","XVIZLoaderInterface"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global WebSocket,ArrayBuffer */\n/* eslint-disable camelcase */\nimport assert from 'assert';\nimport {XVIZStreamBuffer, parseStreamMessage} from '@xviz/parser';\nimport PromiseRetry from 'promise-retry';\n\nimport XVIZLoaderInterface from './xviz-loader-interface';\nimport XVIZController from './xviz-controller-v2';\n\n/**\n * Connect to XVIZ 2 websocket manage storage of XVIZ data into a XVIZStreamBuffer\n *\n * This class is a Websocket base class and is expected to be subclassed with\n * the following methods overridden:\n *\n * - _onOpen()\n */\nexport default class XVIZWebsocketLoader extends XVIZLoaderInterface {\n  /**\n   * constructor\n   * @params serverConfig {object}\n   *   - serverConfig.serverUrl {string}\n   *   - serverConfig.defaultLogLength {number, optional} - default 30\n   *   - serverConfig.queryParams {object, optional}\n   *   - serverConfig.retryAttempts {number, optional} - default 3\n   * @params worker {string|function, optional}\n   * @params maxConcurrency {number, optional} - default 3\n   * @params debug {function} - Debug callback for the XVIZ parser.\n   * @params logGuid {string}\n   * @params logProfile {string, optional}\n   * @params duration {number, optional}\n   * @params timestamp {number, optional}\n   * @params bufferLength {number, optional}\n   */\n  constructor(options = {}) {\n    super(options);\n\n    this.socket = null;\n\n    this.retrySettings = {\n      retries: 3,\n      minTimeout: 500,\n      randomize: true\n    };\n\n    this.streamBuffer = new XVIZStreamBuffer();\n\n    // Handler object for the websocket events\n    // Note: needs to be last due to member dependencies\n    this.WebSocketClass = options.WebSocketClass || WebSocket;\n  }\n\n  isOpen() {\n    return this.socket; // && this.socket.readyState === WEB_SOCKET_OPEN_STATE;\n  }\n\n  seek(timestamp) {\n    super.seek(timestamp);\n  }\n\n  /**\n   * Open an XVIZ socket connection with automatic retry\n   *\n   * @returns {Promise} WebSocket connection\n   */\n  connect() {\n    assert(this.socket === null, 'Socket Manager still connected');\n\n    this._debug('stream_start');\n    const {url} = this.requestParams;\n\n    // Wrap retry logic around connection\n    return PromiseRetry(retry => {\n      return new Promise((resolve, reject) => {\n        try {\n          const ws = new this.WebSocketClass(url);\n          ws.binaryType = 'arraybuffer';\n\n          ws.onmessage = message => {\n            const hasMetadata = Boolean(this.getMetadata());\n\n            return parseStreamMessage({\n              message: message.data,\n              onResult: this.onXVIZMessage,\n              onError: this.onError,\n              debug: this._debug.bind(this, 'parse_message'),\n              worker: hasMetadata && this.options.worker,\n              maxConcurrency: this.options.maxConcurrency\n            });\n          };\n\n          ws.onerror = this.onError;\n          ws.onclose = event => {\n            this._onWSClose(event);\n            reject(event);\n          };\n\n          // On success, resolve the promise with the now ready socket\n          ws.onopen = () => {\n            this.socket = ws;\n            this._onWSOpen();\n            resolve(ws);\n          };\n        } catch (err) {\n          reject(err);\n        }\n      }).catch(event => {\n        this._onWSError(event);\n        const isAbnormalClosure = event.code > 1000 && event.code !== 1005;\n\n        // Retry if abnormal or connection never established\n        if (isAbnormalClosure || !this.socket) {\n          retry();\n        }\n      });\n    }, this.retrySettings).catch(this._onWSError);\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  // Subclasses *MUST* implement these methods\n  _onOpen() {\n    throw new Error('_onOpen() method must be overridden');\n  }\n\n  // PRIVATE Methods\n\n  // Notifications and metric reporting\n  _onWSOpen = () => {\n    // Request data if we are restarting, otherwise wait for metadata\n    // TODO - protocol negotiation\n    this.xvizHandler = new XVIZController(this.socket);\n\n    this._debug('socket_open', this.requestParams);\n    this._onOpen();\n  };\n\n  _onWSClose = event => {\n    // Only called on connection closure, which would be an error case\n    this._debug('socket_closed', event);\n  };\n\n  _onWSError = event => {\n    this._debug('socket_error', event);\n  };\n}\n"],"file":"xviz-websocket-loader.js"}