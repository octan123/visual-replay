{"version":3,"sources":["../../../src/loaders/xviz-websocket-loader.js"],"names":["assert","XVIZStreamBuffer","parseStreamMessage","PromiseRetry","XVIZLoaderInterface","XVIZController","XVIZWebsocketLoader","options","xvizHandler","socket","_debug","requestParams","_onOpen","event","retrySettings","retries","minTimeout","randomize","streamBuffer","WebSocketClass","WebSocket","timestamp","url","retry","Promise","resolve","reject","ws","binaryType","onmessage","message","hasMetadata","Boolean","getMetadata","data","onResult","onXVIZMessage","onError","debug","bind","worker","maxConcurrency","onerror","onclose","_onWSClose","onopen","_onWSOpen","err","_onWSError","isAbnormalClosure","code","close","Error"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global WebSocket,ArrayBuffer */\n/* eslint-disable camelcase */\nimport assert from 'assert';\nimport {XVIZStreamBuffer, parseStreamMessage} from '@xviz/parser';\nimport PromiseRetry from 'promise-retry';\n\nimport XVIZLoaderInterface from './xviz-loader-interface';\nimport XVIZController from './xviz-controller-v2';\n\n/**\n * Connect to XVIZ 2 websocket manage storage of XVIZ data into a XVIZStreamBuffer\n *\n * This class is a Websocket base class and is expected to be subclassed with\n * the following methods overridden:\n *\n * - _onOpen()\n */\nexport default class XVIZWebsocketLoader extends XVIZLoaderInterface {\n  /**\n   * constructor\n   * @params serverConfig {object}\n   *   - serverConfig.serverUrl {string}\n   *   - serverConfig.defaultLogLength {number, optional} - default 30\n   *   - serverConfig.queryParams {object, optional}\n   *   - serverConfig.retryAttempts {number, optional} - default 3\n   * @params worker {string|function, optional}\n   * @params maxConcurrency {number, optional} - default 3\n   * @params debug {function} - Debug callback for the XVIZ parser.\n   * @params logGuid {string}\n   * @params logProfile {string, optional}\n   * @params duration {number, optional}\n   * @params timestamp {number, optional}\n   * @params bufferLength {number, optional}\n   */\n  constructor(options = {}) {\n    super(options);\n\n    this.socket = null;\n\n    this.retrySettings = {\n      retries: 3,\n      minTimeout: 500,\n      randomize: true\n    };\n\n    this.streamBuffer = new XVIZStreamBuffer();\n\n    // Handler object for the websocket events\n    // Note: needs to be last due to member dependencies\n    this.WebSocketClass = options.WebSocketClass || WebSocket;\n  }\n\n  isOpen() {\n    return this.socket; // && this.socket.readyState === WEB_SOCKET_OPEN_STATE;\n  }\n\n  seek(timestamp) {\n    super.seek(timestamp);\n  }\n\n  /**\n   * Open an XVIZ socket connection with automatic retry\n   *\n   * @returns {Promise} WebSocket connection\n   */\n  connect() {\n    assert(this.socket === null, 'Socket Manager still connected');\n\n    this._debug('stream_start');\n    const {url} = this.requestParams;\n\n    // Wrap retry logic around connection\n    return PromiseRetry(retry => {\n      return new Promise((resolve, reject) => {\n        try {\n          const ws = new this.WebSocketClass(url);\n          ws.binaryType = 'arraybuffer';\n\n          ws.onmessage = message => {\n            const hasMetadata = Boolean(this.getMetadata());\n\n            return parseStreamMessage({\n              message: message.data,\n              onResult: this.onXVIZMessage,\n              onError: this.onError,\n              debug: this._debug.bind(this, 'parse_message'),\n              worker: hasMetadata && this.options.worker,\n              maxConcurrency: this.options.maxConcurrency\n            });\n          };\n\n          ws.onerror = this.onError;\n          ws.onclose = event => {\n            this._onWSClose(event);\n            reject(event);\n          };\n\n          // On success, resolve the promise with the now ready socket\n          ws.onopen = () => {\n            this.socket = ws;\n            this._onWSOpen();\n            resolve(ws);\n          };\n        } catch (err) {\n          reject(err);\n        }\n      }).catch(event => {\n        this._onWSError(event);\n        const isAbnormalClosure = event.code > 1000 && event.code !== 1005;\n\n        // Retry if abnormal or connection never established\n        if (isAbnormalClosure || !this.socket) {\n          retry();\n        }\n      });\n    }, this.retrySettings).catch(this._onWSError);\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  // Subclasses *MUST* implement these methods\n  _onOpen() {\n    throw new Error('_onOpen() method must be overridden');\n  }\n\n  // PRIVATE Methods\n\n  // Notifications and metric reporting\n  _onWSOpen = () => {\n    // Request data if we are restarting, otherwise wait for metadata\n    // TODO - protocol negotiation\n    this.xvizHandler = new XVIZController(this.socket);\n\n    this._debug('socket_open', this.requestParams);\n    this._onOpen();\n  };\n\n  _onWSClose = event => {\n    // Only called on connection closure, which would be an error case\n    this._debug('socket_closed', event);\n  };\n\n  _onWSError = event => {\n    this._debug('socket_error', event);\n  };\n}\n"],"file":"xviz-websocket-loader.js"}