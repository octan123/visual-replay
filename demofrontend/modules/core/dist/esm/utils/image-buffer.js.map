{"version":3,"sources":["../../../src/utils/image-buffer.js"],"names":["getXVIZConfig","loadImage","frame","blob","Blob","imageData","type","imageType","createImageBitmap","Promise","resolve","reject","image","Image","onload","onerror","src","URL","createObjectURL","error","deleteImage","close","ImageBuffer","size","imageLoader","imageDeleter","buffer","Map","get","allFrames","currentTime","_getCurrentFrames","currentFrame","bufferedFrames","keys","length","time","forEach","has","data","promise","images","then","set","currentFrameIndex","bestDelta","TIME_WINDOW","i","delta","slice","Math","max"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global createImageBitmap, Blob, Image, URL  */\nimport {getXVIZConfig} from '@xviz/parser';\n\n/* Loads the image data from a frame of a XVIZ image stream */\nfunction loadImage(frame) {\n  const blob = new Blob([frame.imageData], {type: frame.imageType});\n\n  if (typeof createImageBitmap !== 'undefined') {\n    return createImageBitmap(blob);\n  }\n  return new Promise((resolve, reject) => {\n    try {\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.onerror = reject;\n      image.src = URL.createObjectURL(blob);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n/* Disposes of all graphical resources associated with the image */\nfunction deleteImage(image) {\n  if (image.close) {\n    // Is ImageBitmap\n    image.close();\n  }\n}\n\n/* Manages loaded images for a XVIZ image stream */\nexport default class ImageBuffer {\n  constructor(size, {imageLoader = loadImage, imageDeleter = deleteImage} = {}) {\n    this.size = size;\n    this.imageLoader = imageLoader;\n    this.imageDeleter = imageDeleter;\n    this.buffer = new Map();\n  }\n\n  get(frame) {\n    return this.buffer.get(frame);\n  }\n\n  set(allFrames, currentTime) {\n    const {buffer} = this;\n\n    const {currentFrame, bufferedFrames} = this._getCurrentFrames(allFrames, currentTime);\n\n    // Remove images outside of the buffer range\n    for (const frame of buffer.keys()) {\n      if (\n        bufferedFrames.length === 0 ||\n        frame.time < bufferedFrames[0].time ||\n        frame.time > bufferedFrames[bufferedFrames.length - 1].time\n      ) {\n        this.imageDeleter(buffer.get(frame));\n        buffer.delete(frame);\n      }\n    }\n\n    // Load images for frames in the buffer\n    bufferedFrames.forEach(frame => {\n      if (!buffer.has(frame)) {\n        const data = {};\n\n        data.promise = this.imageLoader(frame.images[0]).then(image => {\n          data.image = image;\n          return image;\n        });\n\n        buffer.set(frame, data);\n      }\n    });\n\n    return currentFrame;\n  }\n\n  _getCurrentFrames(allFrames, currentTime) {\n    let currentFrame = null;\n    let currentFrameIndex = -1;\n    let bestDelta = getXVIZConfig().TIME_WINDOW;\n\n    // Find the frame closest to the current timestamp\n    allFrames.forEach((frame, i) => {\n      const delta = currentTime - frame.time;\n      if (delta >= 0 && delta < bestDelta) {\n        bestDelta = delta;\n        currentFrame = frame;\n        currentFrameIndex = i;\n      }\n    });\n\n    // Load adjacent frames into the buffer\n    const bufferedFrames =\n      currentFrameIndex >= 0\n        ? allFrames.slice(Math.max(0, currentFrameIndex - this.size), currentFrameIndex + this.size)\n        : [];\n\n    return {currentFrame, bufferedFrames};\n  }\n}\n"],"file":"image-buffer.js"}