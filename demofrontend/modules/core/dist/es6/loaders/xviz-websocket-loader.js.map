{"version":3,"sources":["../../../src/loaders/xviz-websocket-loader.js"],"names":["assert","XVIZStreamBuffer","parseStreamMessage","PromiseRetry","XVIZLoaderInterface","XVIZController","XVIZWebsocketLoader","constructor","options","xvizHandler","socket","_debug","requestParams","_onOpen","event","retrySettings","retries","minTimeout","randomize","streamBuffer","WebSocketClass","WebSocket","isOpen","seek","timestamp","connect","url","retry","Promise","resolve","reject","ws","binaryType","onmessage","message","hasMetadata","Boolean","getMetadata","data","onResult","onXVIZMessage","onError","debug","bind","worker","maxConcurrency","onerror","onclose","_onWSClose","onopen","_onWSOpen","err","catch","_onWSError","isAbnormalClosure","code","close","Error"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global WebSocket,ArrayBuffer */\n/* eslint-disable camelcase */\nimport assert from 'assert';\nimport {XVIZStreamBuffer, parseStreamMessage} from '@xviz/parser';\nimport PromiseRetry from 'promise-retry';\n\nimport XVIZLoaderInterface from './xviz-loader-interface';\nimport XVIZController from './xviz-controller-v2';\n\n/**\n * Connect to XVIZ 2 websocket manage storage of XVIZ data into a XVIZStreamBuffer\n *\n * This class is a Websocket base class and is expected to be subclassed with\n * the following methods overridden:\n *\n * - _onOpen()\n */\nexport default class XVIZWebsocketLoader extends XVIZLoaderInterface {\n  /**\n   * constructor\n   * @params serverConfig {object}\n   *   - serverConfig.serverUrl {string}\n   *   - serverConfig.defaultLogLength {number, optional} - default 30\n   *   - serverConfig.queryParams {object, optional}\n   *   - serverConfig.retryAttempts {number, optional} - default 3\n   * @params worker {string|function, optional}\n   * @params maxConcurrency {number, optional} - default 3\n   * @params debug {function} - Debug callback for the XVIZ parser.\n   * @params logGuid {string}\n   * @params logProfile {string, optional}\n   * @params duration {number, optional}\n   * @params timestamp {number, optional}\n   * @params bufferLength {number, optional}\n   */\n  constructor(options = {}) {\n    super(options);\n\n    this.socket = null;\n\n    this.retrySettings = {\n      retries: 3,\n      minTimeout: 500,\n      randomize: true\n    };\n\n    this.streamBuffer = new XVIZStreamBuffer();\n\n    // Handler object for the websocket events\n    // Note: needs to be last due to member dependencies\n    this.WebSocketClass = options.WebSocketClass || WebSocket;\n  }\n\n  isOpen() {\n    return this.socket; // && this.socket.readyState === WEB_SOCKET_OPEN_STATE;\n  }\n\n  seek(timestamp) {\n    super.seek(timestamp);\n  }\n\n  /**\n   * Open an XVIZ socket connection with automatic retry\n   *\n   * @returns {Promise} WebSocket connection\n   */\n  connect() {\n    assert(this.socket === null, 'Socket Manager still connected');\n\n    this._debug('stream_start');\n    const {url} = this.requestParams;\n\n    // Wrap retry logic around connection\n    return PromiseRetry(retry => {\n      return new Promise((resolve, reject) => {\n        try {\n          const ws = new this.WebSocketClass(url);\n          ws.binaryType = 'arraybuffer';\n\n          ws.onmessage = message => {\n            const hasMetadata = Boolean(this.getMetadata());\n\n            return parseStreamMessage({\n              message: message.data,\n              onResult: this.onXVIZMessage,\n              onError: this.onError,\n              debug: this._debug.bind(this, 'parse_message'),\n              worker: hasMetadata && this.options.worker,\n              maxConcurrency: this.options.maxConcurrency\n            });\n          };\n\n          ws.onerror = this.onError;\n          ws.onclose = event => {\n            this._onWSClose(event);\n            reject(event);\n          };\n\n          // On success, resolve the promise with the now ready socket\n          ws.onopen = () => {\n            this.socket = ws;\n            this._onWSOpen();\n            resolve(ws);\n          };\n        } catch (err) {\n          reject(err);\n        }\n      }).catch(event => {\n        this._onWSError(event);\n        const isAbnormalClosure = event.code > 1000 && event.code !== 1005;\n\n        // Retry if abnormal or connection never established\n        if (isAbnormalClosure || !this.socket) {\n          retry();\n        }\n      });\n    }, this.retrySettings).catch(this._onWSError);\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close();\n      this.socket = null;\n    }\n  }\n\n  // Subclasses *MUST* implement these methods\n  _onOpen() {\n    throw new Error('_onOpen() method must be overridden');\n  }\n\n  // PRIVATE Methods\n\n  // Notifications and metric reporting\n  _onWSOpen = () => {\n    // Request data if we are restarting, otherwise wait for metadata\n    // TODO - protocol negotiation\n    this.xvizHandler = new XVIZController(this.socket);\n\n    this._debug('socket_open', this.requestParams);\n    this._onOpen();\n  };\n\n  _onWSClose = event => {\n    // Only called on connection closure, which would be an error case\n    this._debug('socket_closed', event);\n  };\n\n  _onWSError = event => {\n    this._debug('socket_error', event);\n  };\n}\n"],"file":"xviz-websocket-loader.js"}