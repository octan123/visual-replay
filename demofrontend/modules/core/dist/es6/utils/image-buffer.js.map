{"version":3,"sources":["../../../src/utils/image-buffer.js"],"names":["getXVIZConfig","loadImage","frame","blob","Blob","imageData","type","imageType","createImageBitmap","Promise","resolve","reject","image","Image","onload","onerror","src","URL","createObjectURL","error","deleteImage","close","ImageBuffer","constructor","size","imageLoader","imageDeleter","buffer","Map","get","set","allFrames","currentTime","currentFrame","bufferedFrames","_getCurrentFrames","keys","length","time","delete","forEach","has","data","promise","images","then","currentFrameIndex","bestDelta","TIME_WINDOW","i","delta","slice","Math","max"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global createImageBitmap, Blob, Image, URL  */\nimport {getXVIZConfig} from '@xviz/parser';\n\n/* Loads the image data from a frame of a XVIZ image stream */\nfunction loadImage(frame) {\n  const blob = new Blob([frame.imageData], {type: frame.imageType});\n\n  if (typeof createImageBitmap !== 'undefined') {\n    return createImageBitmap(blob);\n  }\n  return new Promise((resolve, reject) => {\n    try {\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.onerror = reject;\n      image.src = URL.createObjectURL(blob);\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n/* Disposes of all graphical resources associated with the image */\nfunction deleteImage(image) {\n  if (image.close) {\n    // Is ImageBitmap\n    image.close();\n  }\n}\n\n/* Manages loaded images for a XVIZ image stream */\nexport default class ImageBuffer {\n  constructor(size, {imageLoader = loadImage, imageDeleter = deleteImage} = {}) {\n    this.size = size;\n    this.imageLoader = imageLoader;\n    this.imageDeleter = imageDeleter;\n    this.buffer = new Map();\n  }\n\n  get(frame) {\n    return this.buffer.get(frame);\n  }\n\n  set(allFrames, currentTime) {\n    const {buffer} = this;\n\n    const {currentFrame, bufferedFrames} = this._getCurrentFrames(allFrames, currentTime);\n\n    // Remove images outside of the buffer range\n    for (const frame of buffer.keys()) {\n      if (\n        bufferedFrames.length === 0 ||\n        frame.time < bufferedFrames[0].time ||\n        frame.time > bufferedFrames[bufferedFrames.length - 1].time\n      ) {\n        this.imageDeleter(buffer.get(frame));\n        buffer.delete(frame);\n      }\n    }\n\n    // Load images for frames in the buffer\n    bufferedFrames.forEach(frame => {\n      if (!buffer.has(frame)) {\n        const data = {};\n\n        data.promise = this.imageLoader(frame.images[0]).then(image => {\n          data.image = image;\n          return image;\n        });\n\n        buffer.set(frame, data);\n      }\n    });\n\n    return currentFrame;\n  }\n\n  _getCurrentFrames(allFrames, currentTime) {\n    let currentFrame = null;\n    let currentFrameIndex = -1;\n    let bestDelta = getXVIZConfig().TIME_WINDOW;\n\n    // Find the frame closest to the current timestamp\n    allFrames.forEach((frame, i) => {\n      const delta = currentTime - frame.time;\n      if (delta >= 0 && delta < bestDelta) {\n        bestDelta = delta;\n        currentFrame = frame;\n        currentFrameIndex = i;\n      }\n    });\n\n    // Load adjacent frames into the buffer\n    const bufferedFrames =\n      currentFrameIndex >= 0\n        ? allFrames.slice(Math.max(0, currentFrameIndex - this.size), currentFrameIndex + this.size)\n        : [];\n\n    return {currentFrame, bufferedFrames};\n  }\n}\n"],"file":"image-buffer.js"}