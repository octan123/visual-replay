{"version":3,"sources":["../../../src/messages/sensor-pointcloud2-converter.js"],"names":["Converter","_","loadProcessedLidarData","SensorPointCloud2","constructor","config","previousData","name","messageType","convertMessage","frame","xvizBuilder","_buildPoints","topic","color","data","message","pointsSize","length","height","width","positions","primitive","xvizStream","points","style","fill_color","getMetadata","xvizMetaBuilder","context","frameIdToPoseMap","streamMetadata","stream","category","type","streamStyle","radiusPixels","frameId","pose","pick","coordinate"],"mappings":"AAcA,OAAOA,SAAP,MAAsB,aAAtB;AACA,OAAOC,CAAP,MAAc,QAAd;AACA,SAAQC,sBAAR,QAAqC,0BAArC;AAEA,OAAO,MAAMC,iBAAN,SAAgCH,SAAhC,CAA0C;AAC/CI,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB,UAAMA,MAAN;AACA,SAAKC,YAAL,GAAoB,EAApB;AACD;;AAED,aAAWC,IAAX,GAAkB;AAChB,WAAO,mBAAP;AACD;;AAED,aAAWC,WAAX,GAAyB;AACvB,WAAO,yBAAP;AACD;;AAED,QAAMC,cAAN,CAAqBC,KAArB,EAA4BC,WAA5B,EAAyC;AACvC,SAAKC,YAAL,CAAkBF,KAAlB,EAAyBC,WAAzB,EAAsC;AACpCE,MAAAA,KAAK,EAAE,KAAKA,KADwB;AAEpCC,MAAAA,KAAK,EAAE;AAF6B,KAAtC;AAID;;AAEDF,EAAAA,YAAY,CAACF,KAAD,EAAQC,WAAR,EAAqB;AAACG,IAAAA,KAAD;AAAQD,IAAAA;AAAR,GAArB,EAAqC;AAC/C,QAAIE,IAAI,GAAGL,KAAK,CAACG,KAAD,CAAhB;;AACA,QAAI,CAACE,IAAL,EAAW;AACTA,MAAAA,IAAI,GAAG,KAAKT,YAAL,CAAkBO,KAAlB,CAAP;;AACA,UAAI,CAACE,IAAL,EAAW;AACT;AACD;AACF;;AACD,SAAKT,YAAL,CAAkBO,KAAlB,IAA2BE,IAA3B;;AAEA,SAAK,MAAM;AAACC,MAAAA;AAAD,KAAX,IAAwBD,IAAxB,EAA8B;AAC5B,YAAME,UAAU,GAAGD,OAAO,CAACD,IAAR,CAAaG,MAAb,IAAuBF,OAAO,CAACG,MAAR,GAAiBH,OAAO,CAACI,KAAhD,CAAnB;AACA,YAAM;AAACC,QAAAA;AAAD,UAAcnB,sBAAsB,CAACc,OAAO,CAACD,IAAT,EAAeE,UAAf,CAA1C;AAEAN,MAAAA,WAAW,CACRW,SADH,CACa,KAAKC,UADlB,EAEGC,MAFH,CAEUH,SAFV,EAGGI,KAHH,CAGS;AAACC,QAAAA,UAAU,EAAEZ;AAAb,OAHT;AAID;AACF;;AAEDa,EAAAA,WAAW,CAACC,eAAD,EAAkBC,OAAlB,EAA2B;AACpC,UAAM;AAACC,MAAAA;AAAD,QAAqBD,OAA3B;AAEA,UAAME,cAAc,GAAGH,eAAe,CACnCI,MADoB,CACb,KAAKT,UADQ,EAEpBU,QAFoB,CAEX,WAFW,EAGpBC,IAHoB,CAGf,OAHe,EAIpBC,WAJoB,CAIR;AACXT,MAAAA,UAAU,EAAE,MADD;AAEXU,MAAAA,YAAY,EAAE;AAFH,KAJQ,CAAvB;AAUA,UAAMC,OAAO,GAAG,KAAKhC,MAAL,CAAYgC,OAAZ,IAAuB,UAAvC;AACA,UAAMC,IAAI,GAAG,CAACR,gBAAgB,IAAI,EAArB,EAAyBO,OAAzB,CAAb;;AAEA,QAAIC,IAAJ,EAAU;AACRP,MAAAA,cAAc,CACXO,IADH,CACQrC,CAAC,CAACsC,IAAF,CAAOD,IAAP,EAAa,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAb,CADR,EACuCrC,CAAC,CAACsC,IAAF,CAAOD,IAAP,EAAa,CAAC,OAAD,EAAU,MAAV,EAAkB,KAAlB,CAAb,CADvC,EAEGE,UAFH,CAEc,kBAFd;AAGD;AACF;;AA/D8C","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable camelcase */\nimport Converter from './converter';\nimport _ from 'lodash';\nimport {loadProcessedLidarData} from './lib/parse-lidar-points';\n\nexport class SensorPointCloud2 extends Converter {\n  constructor(config) {\n    super(config);\n    this.previousData = {};\n  }\n\n  static get name() {\n    return 'SensorPointCloud2';\n  }\n\n  static get messageType() {\n    return 'sensor_msgs/PointCloud2';\n  }\n\n  async convertMessage(frame, xvizBuilder) {\n    this._buildPoints(frame, xvizBuilder, {\n      topic: this.topic,\n      color: '#00ff00aa'\n    });\n  }\n\n  _buildPoints(frame, xvizBuilder, {color, topic}) {\n    let data = frame[topic];\n    if (!data) {\n      data = this.previousData[topic];\n      if (!data) {\n        return;\n      }\n    }\n    this.previousData[topic] = data;\n\n    for (const {message} of data) {\n      const pointsSize = message.data.length / (message.height * message.width);\n      const {positions} = loadProcessedLidarData(message.data, pointsSize);\n\n      xvizBuilder\n        .primitive(this.xvizStream)\n        .points(positions)\n        .style({fill_color: color});\n    }\n  }\n\n  getMetadata(xvizMetaBuilder, context) {\n    const {frameIdToPoseMap} = context;\n\n    const streamMetadata = xvizMetaBuilder\n      .stream(this.xvizStream)\n      .category('primitive')\n      .type('point')\n      .streamStyle({\n        fill_color: '#00a',\n        radiusPixels: 3\n      });\n\n    // By convention velodyne is common, but it others may be used.\n    const frameId = this.config.frameId || 'velodyne';\n    const pose = (frameIdToPoseMap || {})[frameId];\n\n    if (pose) {\n      streamMetadata\n        .pose(_.pick(pose, ['x', 'y', 'z']), _.pick(pose, ['pitch', 'roll', 'yaw']))\n        .coordinate('VEHICLE_RELATIVE');\n    }\n  }\n}\n"],"file":"sensor-pointcloud2-converter.js"}