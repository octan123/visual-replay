{"version":3,"sources":["../../../../src/messages/lib/parse-lidar-points.js"],"names":["loadRawLidarData","uint8Array","pointSize","pointsCount","length","buf","Buffer","from","positions","Float32Array","reflectance","i","readFloatLE","loadProcessedLidarData","module","exports"],"mappings":";;AAiBA,SAASA,gBAAT,CAA0BC,UAA1B,EAAsCC,SAAtC,EAAiD;AAc/C,MAAMC,WAAW,GAAGF,UAAU,CAACG,MAAX,GAAoBF,SAAxC;AACA,MAAMG,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYN,UAAZ,CAAZ;AAGA,MAAMO,SAAS,GAAG,IAAIC,YAAJ,CAAiB,IAAIN,WAArB,CAAlB;AACA,MAAMO,WAAW,GAAG,IAAID,YAAJ,CAAiBN,WAAjB,CAApB;;AAEA,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,WAApB,EAAiCQ,CAAC,EAAlC,EAAsC;AACpCH,IAAAA,SAAS,CAACG,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAApB,CAAvB;AACAM,IAAAA,SAAS,CAACG,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAAJ,GAAgB,CAAhC,CAAvB;AACAM,IAAAA,SAAS,CAACG,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAAJ,GAAgB,CAAhC,CAAvB;AACAQ,IAAAA,WAAW,CAACC,CAAD,CAAX,GAAiBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAAJ,GAAgB,EAAhC,CAAjB;AACD;;AACD,SAAO;AAACM,IAAAA,SAAS,EAATA,SAAD;AAAYE,IAAAA,WAAW,EAAXA;AAAZ,GAAP;AACD;;AAED,SAASG,sBAAT,CAAgCZ,UAAhC,EAA4CC,SAA5C,EAAuD;AAWrD,MAAMC,WAAW,GAAGF,UAAU,CAACG,MAAX,GAAoBF,SAAxC;AACA,MAAMG,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAYN,UAAZ,CAAZ;AAGA,MAAMO,SAAS,GAAG,IAAIC,YAAJ,CAAiB,IAAIN,WAArB,CAAlB;AACA,MAAMO,WAAW,GAAG,IAAID,YAAJ,CAAiBN,WAAjB,CAApB;;AAEA,OAAK,IAAIQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,WAApB,EAAiCQ,CAAC,EAAlC,EAAsC;AACpCH,IAAAA,SAAS,CAACG,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAApB,CAAvB;AACAM,IAAAA,SAAS,CAACG,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAAJ,GAAgB,CAAhC,CAAvB;AACAM,IAAAA,SAAS,CAACG,CAAC,GAAG,CAAJ,GAAQ,CAAT,CAAT,GAAuBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAAJ,GAAgB,CAAhC,CAAvB;AACAQ,IAAAA,WAAW,CAACC,CAAD,CAAX,GAAiBN,GAAG,CAACO,WAAJ,CAAgBD,CAAC,GAAGT,SAAJ,GAAgB,EAAhC,CAAjB;AACD;;AACD,SAAO;AAACM,IAAAA,SAAS,EAATA,SAAD;AAAYE,IAAAA,WAAW,EAAXA;AAAZ,GAAP;AACD;;AAEDI,MAAM,CAACC,OAAP,GAAiB;AACff,EAAAA,gBAAgB,EAAhBA,gBADe;AAEfa,EAAAA,sBAAsB,EAAtBA;AAFe,CAAjB","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Parse LiDar data (stored in velodyne_points dir),\n */\n\nfunction loadRawLidarData(uint8Array, pointSize) {\n  /*\n    Data Fields:\n    datatypes (http://docs.ros.org/api/sensor_msgs/html/msg/PointField.html)\n      4: uint16\n      7: float32\n    [\n      { name: 'x', offset: 0, datatype: 7, count: 1 },\n      { name: 'y', offset: 4, datatype: 7, count: 1 },\n      { name: 'z', offset: 8, datatype: 7, count: 1 },\n      { name: 'intensity', offset: 16, datatype: 7, count: 1 },\n      { name: 'ring', offset: 20, datatype: 4, count: 1 }\n    ]\n   */\n  const pointsCount = uint8Array.length / pointSize;\n  const buf = Buffer.from(uint8Array); // eslint-disable-line\n\n  // We could return interleaved buffers, no conversion!\n  const positions = new Float32Array(3 * pointsCount);\n  const reflectance = new Float32Array(pointsCount);\n\n  for (let i = 0; i < pointsCount; i++) {\n    positions[i * 3 + 0] = buf.readFloatLE(i * pointSize);\n    positions[i * 3 + 1] = buf.readFloatLE(i * pointSize + 4);\n    positions[i * 3 + 2] = buf.readFloatLE(i * pointSize + 8);\n    reflectance[i] = buf.readFloatLE(i * pointSize + 16);\n  }\n  return {positions, reflectance};\n}\n\nfunction loadProcessedLidarData(uint8Array, pointSize) {\n  /*\n    Data Fields:\n    datatypes (http://docs.ros.org/api/sensor_msgs/html/msg/PointField.html)\n      7: float32\n    [\n      { name: 'x', offset: 0, datatype: 7, count: 1 },\n      { name: 'y', offset: 4, datatype: 7, count: 1 },\n      { name: 'z', offset: 8, datatype: 7, count: 1 },\n      { name: 'intensity', offset: 12, datatype: 7, count: 1 } ]\n   */\n  const pointsCount = uint8Array.length / pointSize;\n  const buf = Buffer.from(uint8Array); // eslint-disable-line\n\n  // We could return interleaved buffers, no conversion!\n  const positions = new Float32Array(3 * pointsCount);\n  const reflectance = new Float32Array(pointsCount);\n\n  for (let i = 0; i < pointsCount; i++) {\n    positions[i * 3 + 0] = buf.readFloatLE(i * pointSize);\n    positions[i * 3 + 1] = buf.readFloatLE(i * pointSize + 4);\n    positions[i * 3 + 2] = buf.readFloatLE(i * pointSize + 8);\n    reflectance[i] = buf.readFloatLE(i * pointSize + 12);\n  }\n  return {positions, reflectance};\n}\n\nmodule.exports = {\n  loadRawLidarData,\n  loadProcessedLidarData\n};\n"],"file":"parse-lidar-points.js"}