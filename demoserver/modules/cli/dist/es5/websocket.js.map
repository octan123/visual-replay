{"version":3,"sources":["../../src/websocket.js"],"names":["WebSocketInterface","options","middleware","start","socket","unknownMessageTypes","Set","onerror","error","console","log","onclose","onClose","onopen","onConnect","onmessage","message","onMessage","close","sendMessage","onStart","toString","data","parsed","processMessage","utf8decoder","TextDecoder","JSON","parse","decode","unpacked","namespace","callMiddleware","type","has","add","msgType","enveloped","send","stringify","xvizType","onError","onMetadata","onTransformLog","onStateUpdate","onTransformLogDone"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* eslint no-console: [\"error\", { allow: [\"log\"] }] */\n/* eslint-env node, browser */\n\nimport {isEnvelope, unpackEnvelope, parseBinaryXVIZ, isBinaryXVIZ} from '@xviz/io';\n\n/**\n * Using the provided W3CWebSocket client, send the optional start\n * message de-envelope the messages and push the results through the\n * XVIZ middlewares.\n */\nexport class WebSocketInterface {\n  constructor(options = {}) {\n    this.middleware = options.middleware;\n    this.start = options.start;\n    this.socket = options.socket;\n    this.unknownMessageTypes = new Set([]);\n\n    this.socket.onerror = error => {\n      console.log('WebSocket Error: ', error);\n    };\n\n    this.socket.onclose = () => {\n      this.onClose();\n    };\n\n    this.socket.onopen = () => {\n      this.onConnect();\n    };\n\n    this.socket.onmessage = message => {\n      this.onMessage(message);\n    };\n  }\n\n  close() {\n    this.socket.close();\n  }\n\n  onConnect() {\n    this.middleware.onConnect();\n\n    if (this.start) {\n      this.sendMessage('start', this.start);\n    } else {\n      // Start is inline so with no message\n      this.middleware.onStart(null);\n    }\n  }\n\n  onError(error) {\n    console.log('Connection Error: ', error.toString());\n  }\n\n  onClose(message) {\n    this.middleware.onClose();\n  }\n\n  onMessage(message) {\n    if (typeof message.data !== 'string') {\n      if (isBinaryXVIZ(message.data)) {\n        // Convert from binary to JSON object\n        const parsed = parseBinaryXVIZ(message.data);\n        this.processMessage(parsed);\n      } else {\n        const utf8decoder = new TextDecoder();\n        const parsed = JSON.parse(utf8decoder.decode(message.data));\n        this.processMessage(parsed);\n      }\n    } else {\n      const parsed = JSON.parse(message.data);\n      this.processMessage(parsed);\n    }\n  }\n\n  processMessage(parsed) {\n    if (isEnvelope(parsed)) {\n      const unpacked = unpackEnvelope(parsed);\n\n      if (unpacked.namespace === 'xviz') {\n        this.callMiddleware(unpacked.type, unpacked.data);\n      } else if (!this.unknownMessageTypes.has(parsed.type)) {\n        // Report each unknown type just once\n        this.unknownMessageTypes.add(parsed.type);\n        console.log(`Unknown message namespace: \"${unpacked.namespace}\" type: \"${unpacked.type}\"`);\n      }\n    } else {\n      console.log('Unknown message format', parsed);\n    }\n  }\n  sendMessage(msgType, data) {\n    this.callMiddleware(msgType, data);\n\n    // TODO: use XVIZEnvelope\n    const enveloped = {\n      type: `xviz/${msgType}`,\n      data\n    };\n    this.socket.send(JSON.stringify(enveloped));\n  }\n\n  callMiddleware(xvizType, data) {\n    switch (xvizType) {\n      case 'start':\n        this.middleware.onStart(data);\n        break;\n      case 'error':\n        this.middleware.onError(data);\n        break;\n      case 'metadata':\n        this.middleware.onMetadata(data);\n        break;\n      case 'transform_log':\n        this.middleware.onTransformLog(data);\n        break;\n      case 'state_update':\n        this.middleware.onStateUpdate(data);\n        break;\n      case 'transform_log_done':\n        this.middleware.onTransformLogDone(data);\n        break;\n      default:\n        // TODO(jlisee): handle unknown XVIZ message type\n        console.log('UNKNOWN XVIZ', xvizType, data);\n        break;\n    }\n  }\n}\n"],"file":"websocket.js"}