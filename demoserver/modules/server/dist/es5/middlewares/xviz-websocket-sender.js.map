{"version":3,"sources":["../../../src/middlewares/xviz-websocket-sender.js"],"names":["WebsocketSink","socket","options","name","data","compress","send","XVIZWebsocketSender","context","sink","format","XVIZ_FORMAT","OBJECT","BINARY_GLB","writer","writerFormat","_syncFormatWithWriter","logger","log","XVIZFormatWriter","resp","sourceFormat","hasMessage","msg","buffer","byteLength","response","JSON","stringify","writeSync","_getFormatOptions","_sendDataDirect","writeMetadata","writeMessage"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport {XVIZ_FORMAT, XVIZFormatWriter} from '@xviz/io';\n\nexport class WebsocketSink {\n  constructor(socket, options) {\n    this.socket = socket;\n    this.options = options;\n  }\n\n  writeSync(name, data) {\n    let {compress = false} = this.options;\n    if (typeof data === 'string') {\n      compress = true;\n    }\n\n    this.socket.send(data, {compress});\n  }\n}\n\n// Send message through the websocket taking into account\n// that only string and arraybuffer data can be sent.\n//\n// Only stateUpdates are sent as binary, everything else\n// is assumed to just be JSON strings (generally short ones).\n//\nexport class XVIZWebsocketSender {\n  constructor(context, socket, options = {}) {\n    this.context = context;\n    this.socket = socket;\n    this.sink = new WebsocketSink(socket, options);\n\n    // TODO: options register:\n    // - compress\n    // - formatter\n\n    this.options = options;\n\n    // This is the actual format we use to send data and can change\n    // based on the message.\n    this.format = options.format;\n\n    if (this.format === XVIZ_FORMAT.OBJECT) {\n      // We can not output OBJECT on a websocket\n      this.format = XVIZ_FORMAT.BINARY_GLB;\n    }\n\n    this.writer = null;\n    // If format is undefined we want to send the 'natural' format of\n    // the data (as long as it's not an OBJECT).\n    // Keep track of current 'writer' format\n    this.writerFormat = null;\n\n    this._syncFormatWithWriter(this.format);\n  }\n\n  log(...msg) {\n    const {logger} = this.options;\n    logger.log(...msg);\n  }\n\n  // Sets this.writer based on 'format'\n  _syncFormatWithWriter(format) {\n    // Cover the case where we have a format and no writer or when the\n    // format does not match.\n    if (format && (!this.writer || this.writerFormat !== format)) {\n      this.writer = new XVIZFormatWriter(this.sink, {format});\n      this.writerFormat = format;\n    }\n  }\n\n  // Data is in the desired format and can be written to sink directly\n  _sendDataDirect(format, resp) {\n    const sourceFormat = resp.format;\n\n    // need to check if object() has been called (ie it might be dirty) and repack\n    if (format === sourceFormat && !resp.hasMessage()) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // If the format is unspecified we output the 'natural' format\n  // if it is valid. Make that determination here.\n  _getFormatOptions(msg) {\n    // default should be pass-thru of original data\n    if (!this.format) {\n      // If no format is specified, we send the 'natural' format\n      // but it must be a string or arraybuffer, not an OBJECT\n\n      // Test to determine if msg is either string or arraybuffer\n      if (\n        msg.format === XVIZ_FORMAT.OBJECT ||\n        (!msg.hasMessage() && typeof msg.buffer !== 'string' && !msg.buffer.byteLength)\n      ) {\n        return XVIZ_FORMAT.BINARY_GLB;\n      }\n\n      // return the format set to the current data format\n      return msg.format;\n    }\n\n    return this.format;\n  }\n\n  onError(msg) {\n    // TODO: This message is almost always just a plain object\n    // but the special handling for here feels awkard\n    const response = JSON.stringify(msg.buffer);\n    this.sink.writeSync('error', response);\n  }\n\n  onMetadata(msg) {\n    const format = this._getFormatOptions(msg);\n\n    if (this._sendDataDirect(format, msg)) {\n      this.sink.writeSync(`1-frame`, msg.buffer);\n    } else {\n      this._syncFormatWithWriter(format);\n      this.writer.writeMetadata(msg);\n    }\n  }\n\n  onStateUpdate(msg) {\n    const format = this._getFormatOptions(msg);\n\n    if (this._sendDataDirect(format, msg)) {\n      this.sink.writeSync('2-frame', msg.buffer);\n    } else {\n      this._syncFormatWithWriter(format);\n      this.writer.writeMessage(0, msg);\n    }\n  }\n\n  onTransformLogDone(msg) {\n    // TODO: This message is almost always just a plain object\n    // but the special handling for here feels awkard\n    const response = JSON.stringify(msg.buffer);\n    this.sink.writeSync('done', response);\n  }\n}\n"],"file":"xviz-websocket-sender.js"}