{"version":3,"sources":["../../../src/middlewares/xviz-websocket-sender.js"],"names":["XVIZ_FORMAT","XVIZFormatWriter","WebsocketSink","constructor","socket","options","writeSync","name","data","compress","send","XVIZWebsocketSender","context","sink","format","OBJECT","BINARY_GLB","writer","writerFormat","_syncFormatWithWriter","log","msg","logger","_sendDataDirect","resp","sourceFormat","hasMessage","_getFormatOptions","buffer","byteLength","onError","response","JSON","stringify","onMetadata","writeMetadata","onStateUpdate","writeMessage","onTransformLogDone"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport {XVIZ_FORMAT, XVIZFormatWriter} from '@xviz/io';\n\nexport class WebsocketSink {\n  constructor(socket, options) {\n    this.socket = socket;\n    this.options = options;\n  }\n\n  writeSync(name, data) {\n    let {compress = false} = this.options;\n    if (typeof data === 'string') {\n      compress = true;\n    }\n\n    this.socket.send(data, {compress});\n  }\n}\n\n// Send message through the websocket taking into account\n// that only string and arraybuffer data can be sent.\n//\n// Only stateUpdates are sent as binary, everything else\n// is assumed to just be JSON strings (generally short ones).\n//\nexport class XVIZWebsocketSender {\n  constructor(context, socket, options = {}) {\n    this.context = context;\n    this.socket = socket;\n    this.sink = new WebsocketSink(socket, options);\n\n    // TODO: options register:\n    // - compress\n    // - formatter\n\n    this.options = options;\n\n    // This is the actual format we use to send data and can change\n    // based on the message.\n    this.format = options.format;\n\n    if (this.format === XVIZ_FORMAT.OBJECT) {\n      // We can not output OBJECT on a websocket\n      this.format = XVIZ_FORMAT.BINARY_GLB;\n    }\n\n    this.writer = null;\n    // If format is undefined we want to send the 'natural' format of\n    // the data (as long as it's not an OBJECT).\n    // Keep track of current 'writer' format\n    this.writerFormat = null;\n\n    this._syncFormatWithWriter(this.format);\n  }\n\n  log(...msg) {\n    const {logger} = this.options;\n    logger.log(...msg);\n  }\n\n  // Sets this.writer based on 'format'\n  _syncFormatWithWriter(format) {\n    // Cover the case where we have a format and no writer or when the\n    // format does not match.\n    if (format && (!this.writer || this.writerFormat !== format)) {\n      this.writer = new XVIZFormatWriter(this.sink, {format});\n      this.writerFormat = format;\n    }\n  }\n\n  // Data is in the desired format and can be written to sink directly\n  _sendDataDirect(format, resp) {\n    const sourceFormat = resp.format;\n\n    // need to check if object() has been called (ie it might be dirty) and repack\n    if (format === sourceFormat && !resp.hasMessage()) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // If the format is unspecified we output the 'natural' format\n  // if it is valid. Make that determination here.\n  _getFormatOptions(msg) {\n    // default should be pass-thru of original data\n    if (!this.format) {\n      // If no format is specified, we send the 'natural' format\n      // but it must be a string or arraybuffer, not an OBJECT\n\n      // Test to determine if msg is either string or arraybuffer\n      if (\n        msg.format === XVIZ_FORMAT.OBJECT ||\n        (!msg.hasMessage() && typeof msg.buffer !== 'string' && !msg.buffer.byteLength)\n      ) {\n        return XVIZ_FORMAT.BINARY_GLB;\n      }\n\n      // return the format set to the current data format\n      return msg.format;\n    }\n\n    return this.format;\n  }\n\n  onError(msg) {\n    // TODO: This message is almost always just a plain object\n    // but the special handling for here feels awkard\n    const response = JSON.stringify(msg.buffer);\n    this.sink.writeSync('error', response);\n  }\n\n  onMetadata(msg) {\n    const format = this._getFormatOptions(msg);\n\n    if (this._sendDataDirect(format, msg)) {\n      this.sink.writeSync(`1-frame`, msg.buffer);\n    } else {\n      this._syncFormatWithWriter(format);\n      this.writer.writeMetadata(msg);\n    }\n  }\n\n  onStateUpdate(msg) {\n    const format = this._getFormatOptions(msg);\n\n    if (this._sendDataDirect(format, msg)) {\n      this.sink.writeSync('2-frame', msg.buffer);\n    } else {\n      this._syncFormatWithWriter(format);\n      this.writer.writeMessage(0, msg);\n    }\n  }\n\n  onTransformLogDone(msg) {\n    // TODO: This message is almost always just a plain object\n    // but the special handling for here feels awkard\n    const response = JSON.stringify(msg.buffer);\n    this.sink.writeSync('done', response);\n  }\n}\n"],"file":"xviz-websocket-sender.js"}