{"version":3,"sources":["../../../src/middlewares/xviz-websocket-sender.js"],"names":["XVIZ_FORMAT","XVIZFormatWriter","WebsocketSink","socket","options","name","data","compress","send","XVIZWebsocketSender","context","sink","format","OBJECT","BINARY_GLB","writer","writerFormat","_syncFormatWithWriter","logger","log","resp","sourceFormat","hasMessage","msg","buffer","byteLength","response","JSON","stringify","writeSync","_getFormatOptions","_sendDataDirect","writeMetadata","writeMessage"],"mappings":";;AAaA,SAAQA,WAAR,EAAqBC,gBAArB,QAA4C,UAA5C;AAEA,WAAaC,aAAb;AACE,yBAAYC,MAAZ,EAAoBC,OAApB,EAA6B;AAAA;;AAC3B,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAJH;AAAA;AAAA,8BAMYC,IANZ,EAMkBC,IANlB,EAMwB;AAAA,kCACK,KAAKF,OADV,CACfG,QADe;AAAA,UACfA,QADe,sCACJ,KADI;;AAEpB,UAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAC5BC,QAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,WAAKJ,MAAL,CAAYK,IAAZ,CAAiBF,IAAjB,EAAuB;AAACC,QAAAA,QAAQ,EAARA;AAAD,OAAvB;AACD;AAbH;;AAAA;AAAA;AAsBA,WAAaE,mBAAb;AACE,+BAAYC,OAAZ,EAAqBP,MAArB,EAA2C;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACzC,SAAKM,OAAL,GAAeA,OAAf;AACA,SAAKP,MAAL,GAAcA,MAAd;AACA,SAAKQ,IAAL,GAAY,IAAIT,aAAJ,CAAkBC,MAAlB,EAA0BC,OAA1B,CAAZ;AAMA,SAAKA,OAAL,GAAeA,OAAf;AAIA,SAAKQ,MAAL,GAAcR,OAAO,CAACQ,MAAtB;;AAEA,QAAI,KAAKA,MAAL,KAAgBZ,WAAW,CAACa,MAAhC,EAAwC;AAEtC,WAAKD,MAAL,GAAcZ,WAAW,CAACc,UAA1B;AACD;;AAED,SAAKC,MAAL,GAAc,IAAd;AAIA,SAAKC,YAAL,GAAoB,IAApB;;AAEA,SAAKC,qBAAL,CAA2B,KAAKL,MAAhC;AACD;;AA5BH;AAAA;AAAA,0BA8Bc;AAAA,UACHM,MADG,GACO,KAAKd,OADZ,CACHc,MADG;AAEVA,MAAAA,MAAM,CAACC,GAAP,OAAAD,MAAM,YAAN;AACD;AAjCH;AAAA;AAAA,0CAoCwBN,MApCxB,EAoCgC;AAG5B,UAAIA,MAAM,KAAK,CAAC,KAAKG,MAAN,IAAgB,KAAKC,YAAL,KAAsBJ,MAA3C,CAAV,EAA8D;AAC5D,aAAKG,MAAL,GAAc,IAAId,gBAAJ,CAAqB,KAAKU,IAA1B,EAAgC;AAACC,UAAAA,MAAM,EAANA;AAAD,SAAhC,CAAd;AACA,aAAKI,YAAL,GAAoBJ,MAApB;AACD;AACF;AA3CH;AAAA;AAAA,oCA8CkBA,MA9ClB,EA8C0BQ,IA9C1B,EA8CgC;AAC5B,UAAMC,YAAY,GAAGD,IAAI,CAACR,MAA1B;;AAGA,UAAIA,MAAM,KAAKS,YAAX,IAA2B,CAACD,IAAI,CAACE,UAAL,EAAhC,EAAmD;AACjD,eAAO,IAAP;AACD;;AAED,aAAO,KAAP;AACD;AAvDH;AAAA;AAAA,sCA2DoBC,GA3DpB,EA2DyB;AAErB,UAAI,CAAC,KAAKX,MAAV,EAAkB;AAKhB,YACEW,GAAG,CAACX,MAAJ,KAAeZ,WAAW,CAACa,MAA3B,IACC,CAACU,GAAG,CAACD,UAAJ,EAAD,IAAqB,OAAOC,GAAG,CAACC,MAAX,KAAsB,QAA3C,IAAuD,CAACD,GAAG,CAACC,MAAJ,CAAWC,UAFtE,EAGE;AACA,iBAAOzB,WAAW,CAACc,UAAnB;AACD;;AAGD,eAAOS,GAAG,CAACX,MAAX;AACD;;AAED,aAAO,KAAKA,MAAZ;AACD;AA9EH;AAAA;AAAA,4BAgFUW,GAhFV,EAgFe;AAGX,UAAMG,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAeL,GAAG,CAACC,MAAnB,CAAjB;AACA,WAAKb,IAAL,CAAUkB,SAAV,CAAoB,OAApB,EAA6BH,QAA7B;AACD;AArFH;AAAA;AAAA,+BAuFaH,GAvFb,EAuFkB;AACd,UAAMX,MAAM,GAAG,KAAKkB,iBAAL,CAAuBP,GAAvB,CAAf;;AAEA,UAAI,KAAKQ,eAAL,CAAqBnB,MAArB,EAA6BW,GAA7B,CAAJ,EAAuC;AACrC,aAAKZ,IAAL,CAAUkB,SAAV,YAA+BN,GAAG,CAACC,MAAnC;AACD,OAFD,MAEO;AACL,aAAKP,qBAAL,CAA2BL,MAA3B;;AACA,aAAKG,MAAL,CAAYiB,aAAZ,CAA0BT,GAA1B;AACD;AACF;AAhGH;AAAA;AAAA,kCAkGgBA,GAlGhB,EAkGqB;AACjB,UAAMX,MAAM,GAAG,KAAKkB,iBAAL,CAAuBP,GAAvB,CAAf;;AAEA,UAAI,KAAKQ,eAAL,CAAqBnB,MAArB,EAA6BW,GAA7B,CAAJ,EAAuC;AACrC,aAAKZ,IAAL,CAAUkB,SAAV,CAAoB,SAApB,EAA+BN,GAAG,CAACC,MAAnC;AACD,OAFD,MAEO;AACL,aAAKP,qBAAL,CAA2BL,MAA3B;;AACA,aAAKG,MAAL,CAAYkB,YAAZ,CAAyB,CAAzB,EAA4BV,GAA5B;AACD;AACF;AA3GH;AAAA;AAAA,uCA6GqBA,GA7GrB,EA6G0B;AAGtB,UAAMG,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAeL,GAAG,CAACC,MAAnB,CAAjB;AACA,WAAKb,IAAL,CAAUkB,SAAV,CAAoB,MAApB,EAA4BH,QAA5B;AACD;AAlHH;;AAAA;AAAA","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport {XVIZ_FORMAT, XVIZFormatWriter} from '@xviz/io';\n\nexport class WebsocketSink {\n  constructor(socket, options) {\n    this.socket = socket;\n    this.options = options;\n  }\n\n  writeSync(name, data) {\n    let {compress = false} = this.options;\n    if (typeof data === 'string') {\n      compress = true;\n    }\n\n    this.socket.send(data, {compress});\n  }\n}\n\n// Send message through the websocket taking into account\n// that only string and arraybuffer data can be sent.\n//\n// Only stateUpdates are sent as binary, everything else\n// is assumed to just be JSON strings (generally short ones).\n//\nexport class XVIZWebsocketSender {\n  constructor(context, socket, options = {}) {\n    this.context = context;\n    this.socket = socket;\n    this.sink = new WebsocketSink(socket, options);\n\n    // TODO: options register:\n    // - compress\n    // - formatter\n\n    this.options = options;\n\n    // This is the actual format we use to send data and can change\n    // based on the message.\n    this.format = options.format;\n\n    if (this.format === XVIZ_FORMAT.OBJECT) {\n      // We can not output OBJECT on a websocket\n      this.format = XVIZ_FORMAT.BINARY_GLB;\n    }\n\n    this.writer = null;\n    // If format is undefined we want to send the 'natural' format of\n    // the data (as long as it's not an OBJECT).\n    // Keep track of current 'writer' format\n    this.writerFormat = null;\n\n    this._syncFormatWithWriter(this.format);\n  }\n\n  log(...msg) {\n    const {logger} = this.options;\n    logger.log(...msg);\n  }\n\n  // Sets this.writer based on 'format'\n  _syncFormatWithWriter(format) {\n    // Cover the case where we have a format and no writer or when the\n    // format does not match.\n    if (format && (!this.writer || this.writerFormat !== format)) {\n      this.writer = new XVIZFormatWriter(this.sink, {format});\n      this.writerFormat = format;\n    }\n  }\n\n  // Data is in the desired format and can be written to sink directly\n  _sendDataDirect(format, resp) {\n    const sourceFormat = resp.format;\n\n    // need to check if object() has been called (ie it might be dirty) and repack\n    if (format === sourceFormat && !resp.hasMessage()) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // If the format is unspecified we output the 'natural' format\n  // if it is valid. Make that determination here.\n  _getFormatOptions(msg) {\n    // default should be pass-thru of original data\n    if (!this.format) {\n      // If no format is specified, we send the 'natural' format\n      // but it must be a string or arraybuffer, not an OBJECT\n\n      // Test to determine if msg is either string or arraybuffer\n      if (\n        msg.format === XVIZ_FORMAT.OBJECT ||\n        (!msg.hasMessage() && typeof msg.buffer !== 'string' && !msg.buffer.byteLength)\n      ) {\n        return XVIZ_FORMAT.BINARY_GLB;\n      }\n\n      // return the format set to the current data format\n      return msg.format;\n    }\n\n    return this.format;\n  }\n\n  onError(msg) {\n    // TODO: This message is almost always just a plain object\n    // but the special handling for here feels awkard\n    const response = JSON.stringify(msg.buffer);\n    this.sink.writeSync('error', response);\n  }\n\n  onMetadata(msg) {\n    const format = this._getFormatOptions(msg);\n\n    if (this._sendDataDirect(format, msg)) {\n      this.sink.writeSync(`1-frame`, msg.buffer);\n    } else {\n      this._syncFormatWithWriter(format);\n      this.writer.writeMetadata(msg);\n    }\n  }\n\n  onStateUpdate(msg) {\n    const format = this._getFormatOptions(msg);\n\n    if (this._sendDataDirect(format, msg)) {\n      this.sink.writeSync('2-frame', msg.buffer);\n    } else {\n      this._syncFormatWithWriter(format);\n      this.writer.writeMessage(0, msg);\n    }\n  }\n\n  onTransformLogDone(msg) {\n    // TODO: This message is almost always just a plain object\n    // but the special handling for here feels awkard\n    const response = JSON.stringify(msg.buffer);\n    this.sink.writeSync('done', response);\n  }\n}\n"],"file":"xviz-websocket-sender.js"}