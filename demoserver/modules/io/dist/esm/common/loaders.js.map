{"version":3,"sources":["../../../src/common/loaders.js"],"names":["GLTFParser","XVIZ_FORMAT","XVIZ_GLTF_EXTENSION","TextDecoder","MAGIC_PBE1","XVIZ_PROTOBUF_MESSAGE","XVIZ_PROTOBUF_TYPE","Enum","Type","MapField","XVIZ_TYPE_PATTERN","XVIZ_TYPE_VALUE_PATTERN","MAGIC_XVIZ","MAGIC_GLTF","LE","BE","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","getDataContainer","data","undefined","Buffer","ArrayBuffer","isView","getXVIZType","firstChunk","lastChunk","result","match","isEnvelope","type","unpackEnvelope","parts","split","namespace","slice","join","checkMagic","glbArrayBuffer","options","magic","magicAlt","dataView","DataView","magic1","getUint32","isBinaryXVIZ","arrayBuffer","isArrayBuffer","parseBinaryXVIZ","opts","messageFormat","BINARY_PBE","parsePBEXVIZ","gltfParser","parse","createImages","xviz","getApplicationData","getExtension","isGLBXVIZ","getGLBXVIZType","arraybuffer","jsonBuffer","getGLBXVIZJSONBuffer","textDecoder","jsonString","decode","byteOffset","glb","version","byteLength","jsonChunkLength","jsonChunkFormat","GLB_CHUNK_TYPE_JSON","isJSONChunk","jsonChunkByteOffset","Uint8Array","isPBEXVIZ","getPBEXVIZType","strippedBuffer","envelope","Envelope","toObject","String","postProcessUIConfig","msg","ui_config","Object","keys","entry","UIPanelInfo","postProcessProtobuf","pbType","$type","fields","fieldName","field","name","resolvedType","repeated","length","map","valuesById","key","messageType","value","tmpMeta","Metadata","tmpState","StateUpdate","Error","isJSONStringTypeArray","arr","firstChar","find","lastChars","from","lastChar","reverse","fromCharCode","isJSONString","str","beginning","trim","end","startsWith","endsWith","getJSONXVIZType","Number","isFinite","apply","getObjectXVIZType","getXVIZMessageType","isXVIZMessage"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global Buffer */\nimport {GLTFParser} from '../gltf/gltf-parser';\n\nimport {XVIZ_FORMAT, XVIZ_GLTF_EXTENSION} from './constants';\nimport {TextDecoder} from './text-encoding';\nimport {MAGIC_PBE1, XVIZ_PROTOBUF_MESSAGE, XVIZ_PROTOBUF_TYPE} from './protobuf-support';\nimport {Enum, Type, MapField} from 'protobufjs';\n\n// XVIZ Type constants\nconst XVIZ_TYPE_PATTERN = /\"type\":\\s*\"(xviz\\/\\w*)\"/;\nconst XVIZ_TYPE_VALUE_PATTERN = /xviz\\/\\w*/;\n\n// GLB constants\nconst MAGIC_XVIZ = 0x5856495a; // XVIZ in Big-Endian ASCII\nconst MAGIC_GLTF = 0x676c5446; // glTF in Big-Endian ASCII\nconst LE = true; // Binary GLTF is little endian.\nconst BE = false; // Magic needs to be written as BE\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\n/* Data Format Support */\n\n// expected return value of null | binary | string | object\nexport function getDataContainer(data) {\n  if (data === null || data === undefined) {\n    return null;\n  }\n\n  if (data instanceof Buffer || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    return 'binary';\n  }\n\n  // Cover string || object\n  return typeof data;\n}\n\n/* XVIZ Type Support */\n\n// Returns the XVIZ message 'type' from the input strings\n// else null if not found.\nfunction getXVIZType(firstChunk, lastChunk) {\n  let result = firstChunk.match(XVIZ_TYPE_PATTERN);\n  if (!result && lastChunk) {\n    result = lastChunk.match(XVIZ_TYPE_PATTERN);\n  }\n\n  if (result) {\n    // return the first match group which contains the type\n    return result[1];\n  }\n\n  return null;\n}\n\n/* Envelope Support */\n\n// Sniff out whether the JSON data provided is in the XVIZ envelope format\nexport function isEnvelope(data) {\n  return data.type && data.data;\n}\n\n// Parse apart the namespace and type for the enveloped data\nexport function unpackEnvelope(data) {\n  const parts = data.type.split('/');\n  return {\n    namespace: parts[0],\n    type: parts.slice(1).join('/'),\n    data: data.data\n  };\n}\n\n/* Binary Support */\n\n// Check first 4 bytes for a 'magic' value\nfunction checkMagic(glbArrayBuffer, options = {}) {\n  const {magic, magicAlt} = options;\n\n  // GLB Header\n  const dataView = new DataView(glbArrayBuffer);\n  const magic1 = dataView.getUint32(0, BE); // Magic number (the ASCII string 'glTF').\n\n  return magic1 === magic || (magicAlt && magicAlt === magic1);\n}\n\n// Supports GLB and Protobuf formats\nexport function isBinaryXVIZ(arrayBuffer) {\n  const isArrayBuffer = arrayBuffer instanceof ArrayBuffer;\n  return (\n    isArrayBuffer &&\n    (checkMagic(arrayBuffer, {magic: MAGIC_XVIZ, magicAlt: MAGIC_GLTF}) ||\n      checkMagic(arrayBuffer, {magic: MAGIC_PBE1}))\n  );\n}\n\n// Supports GLB and Protobuf formats\nexport function parseBinaryXVIZ(arrayBuffer, opts) {\n  if (\n    (opts && opts.messageFormat === XVIZ_FORMAT.BINARY_PBE) ||\n    checkMagic(arrayBuffer, {magic: MAGIC_PBE1})\n  ) {\n    return parsePBEXVIZ(arrayBuffer, opts);\n  }\n\n  const gltfParser = new GLTFParser();\n  gltfParser.parse(arrayBuffer, {createImages: false});\n\n  // TODO/ib - Fix when loaders.gl API is fixed\n  let xviz = gltfParser.getApplicationData('xviz');\n\n  if (xviz === undefined) {\n    xviz = gltfParser.getExtension(XVIZ_GLTF_EXTENSION);\n  }\n\n  return xviz;\n}\n\n/* GLB Support */\n\nexport function isGLBXVIZ(arrayBuffer) {\n  const isArrayBuffer = arrayBuffer instanceof ArrayBuffer;\n  // MAGIC_XVIZ is a deprecated magic header\n  return isArrayBuffer && checkMagic(arrayBuffer, {magic: MAGIC_XVIZ, magicAlt: MAGIC_GLTF});\n}\n\nfunction getGLBXVIZType(arraybuffer) {\n  const jsonBuffer = getGLBXVIZJSONBuffer(arraybuffer);\n  if (!jsonBuffer) {\n    return null;\n  }\n\n  // We have no choice but to decode the JSON portion of the buffer\n  // since it also contains all the GLB headers. This means we do not\n  // have any meaningful limits for where to search for the 'type' string\n  const textDecoder = new TextDecoder('utf8');\n  const jsonString = textDecoder.decode(jsonBuffer);\n\n  return getXVIZType(jsonString);\n}\n\n// Mostly taken from @loaders.gltf parse-glb.js, but limited to just getting the json chunk\n// as we do not need to parse the binary here.\nfunction getGLBXVIZJSONBuffer(arrayBuffer, byteOffset = 0) {\n  // GLB Header\n  const dataView = new DataView(arrayBuffer);\n  const glb = {};\n\n  glb.byteOffset = byteOffset; // Byte offset into the initial arrayBuffer\n\n  // GLB Header\n  glb.magic = dataView.getUint32(byteOffset + 0, BE); // Magic number (the ASCII string 'glTF').\n  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  glb.byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of generated file\n\n  if (glb.version !== 2 || glb.byteLength < 20) {\n    return null;\n  }\n\n  glb.jsonChunkLength = dataView.getUint32(byteOffset + 12, LE); // Byte length of json chunk\n  glb.jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE); // Chunk format as uint32\n\n  const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\n  const isJSONChunk = glb.jsonChunkFormat === GLB_CHUNK_TYPE_JSON || glb.jsonChunkFormat === 0;\n\n  if (!isJSONChunk) {\n    // JSON should be first and present\n    return null;\n  }\n\n  glb.jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE; // First headers: 20 bytes\n  return new Uint8Array(arrayBuffer, byteOffset + glb.jsonChunkByteOffset, glb.jsonChunkLength);\n}\n\n/* Protobuf Support */\n\nexport function isPBEXVIZ(arrayBuffer) {\n  const isArrayBuffer = arrayBuffer instanceof ArrayBuffer;\n  return isArrayBuffer && checkMagic(arrayBuffer, {magic: MAGIC_PBE1});\n}\n\nfunction getPBEXVIZType(arrayBuffer) {\n  const strippedBuffer = new Uint8Array(arrayBuffer, 4);\n  // TODO: this toObject is too expensive, we can do\n  // this with decode only\n  const envelope = XVIZ_PROTOBUF_MESSAGE.Envelope.toObject(strippedBuffer, {\n    enum: String\n  });\n\n  return envelope.type;\n}\n\nfunction postProcessUIConfig(msg) {\n  if (msg && msg.ui_config) {\n    for (const entry of Object.keys(msg.ui_config)) {\n      msg.ui_config[entry] = XVIZ_PROTOBUF_TYPE.UIPanelInfo.toObject(msg.ui_config[entry]);\n    }\n  }\n}\n\n/* We need to modify the protobufjs objects to work closer to \"normal\"\n * Javascript objects. The protobuf type reflection is available as `msg.$type`\n * which is traversed in parallel to the `msg`.\n *\n * The following mutations are made:\n *\n * - Remove empty Arrays from the instance, protobuf.js will set to the default value: [] (the empty array)\n * - Enum => String\n * - Handle arrays of enum\n * - Recursive on objects\n */\n/* eslint-disable max-depth, complexity */\nfunction postProcessProtobuf(msg, pbType) {\n  const type = pbType || msg.$type;\n\n  if (msg && type && type.fields) {\n    const fields = type.fields;\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n\n      if (field && msg[field.name]) {\n        if (!field.resolvedType && field.repeated && msg[field.name].length === 0) {\n          // Remove empty arrays that are likely the default value\n          msg[field.name] = undefined;\n          delete msg[field.name];\n        } else if (field.resolvedType) {\n          // Handle integer enum to string change\n          if (field.resolvedType instanceof Enum) {\n            if (field.repeated) {\n              if (msg[field.name].length === 0) {\n                // Remove empty arrays that are likely the default value\n                msg[field.name] = undefined;\n                delete msg[field.name];\n              } else {\n                // Map array of enums to strings using reflection information\n                msg[field.name] = msg[field.name].map(\n                  entry => field.resolvedType.valuesById[entry]\n                );\n              }\n            } else {\n              // Map enums to strings using reflection information\n              msg[field.name] = field.resolvedType.valuesById[msg[field.name]];\n            }\n          } else if (field instanceof MapField) {\n            // Recursive processing on key,value field\n            for (const key of Object.keys(msg[field.name])) {\n              msg[field.name][key] = postProcessProtobuf(msg[field.name][key], field.resolvedType);\n            }\n          } else if (field.resolvedType instanceof Type) {\n            // Recursive processing on fields of an object\n            if (field.repeated) {\n              if (msg[field.name].length === 0) {\n                msg[field.name] = undefined;\n                delete msg[field.name];\n              } else {\n                msg[field.name] = msg[field.name].map(entry =>\n                  postProcessProtobuf(entry, field.resolvedType)\n                );\n              }\n            } else {\n              msg[field.name] = postProcessProtobuf(msg[field.name], field.resolvedType);\n            }\n          }\n        }\n      }\n    }\n  }\n  return msg;\n}\n/* eslint-enable max-depth, complexity */\n\n// TODO: unpackEnvelop produces namespace, type data\n// Handle PBE and raw protobuf messages if opts.messageType is supplied\nexport function parsePBEXVIZ(arrayBuffer, opts = {}) {\n  const {messageType} = opts;\n  const xviz = {\n    type: messageType,\n    data: null\n  };\n\n  let data = arrayBuffer;\n\n  // If the type has been provided, it means there is no Envelope so skip that step\n  if (!xviz.type) {\n    const strippedBuffer = new Uint8Array(arrayBuffer, 4);\n    const envelope = XVIZ_PROTOBUF_MESSAGE.Envelope.decode(strippedBuffer);\n    xviz.type = envelope.type;\n    data = envelope.data.value;\n  }\n\n  switch (xviz.type) {\n    case 'xviz/metadata':\n      const tmpMeta = XVIZ_PROTOBUF_MESSAGE.Metadata.decode(data);\n      xviz.data = postProcessProtobuf(tmpMeta);\n      postProcessUIConfig(xviz.data);\n      break;\n    case 'xviz/state_update':\n      const tmpState = XVIZ_PROTOBUF_MESSAGE.StateUpdate.decode(data);\n      xviz.data = postProcessProtobuf(tmpState);\n      break;\n    default:\n      throw new Error(`Unknown Message type ${xviz.type}`);\n  }\n\n  return xviz;\n}\n\n/* JSON Support */\n\n// Return true if the ArrayBuffer represents a JSON string.\n//\n// Search the first and last 5 entries for evidence of\n// being a JSON buffer\nfunction isJSONStringTypeArray(arr) {\n  let firstChar = arr.slice(0, 5).find(entry => entry >= 0x20);\n  let lastChars = arr.slice(-5);\n\n  // Buffer.slice() does not make a copy, but we need one since\n  // we call reverse()\n  if (lastChars instanceof Buffer) {\n    lastChars = Buffer.from(lastChars);\n  }\n\n  let lastChar = lastChars.reverse().find(entry => entry >= 0x20);\n\n  firstChar = String.fromCharCode(firstChar);\n  lastChar = String.fromCharCode(lastChar);\n\n  return (firstChar === '{' && lastChar === '}') || (firstChar === '[' && lastChar === ']');\n}\n\n// returns true if the input represents a JSON string.\n// Can be either string or Uint8Array\n//\n// Search the first and last 5 entries for evidence of\n// being a JSON buffer\nexport function isJSONString(str) {\n  if (str instanceof Uint8Array) {\n    return isJSONStringTypeArray(str);\n  }\n\n  if (typeof str === 'object') {\n    return false;\n  }\n\n  const beginning = str.slice(0, 5).trim();\n  const end = str.slice(-5).trim();\n\n  return (\n    (beginning.startsWith('{') && end.endsWith('}')) ||\n    (beginning.startsWith('[') && end.endsWith(']'))\n  );\n}\n\n// return the XVIZ type string if the input represents an enveloped XVIZ\n// object as a JSON string.\n// 'str' can be either string or Uint8Array\nfunction getJSONXVIZType(str) {\n  // We are trying to capture\n  // \"type\"\\s*:\\s*\"xviz/transform_point_in_time\"\n  // which the smallest is 37 bytes. Grab 50\n  // to provide room for spacing\n\n  // {\"type\":\"xviz/*\"\n  let firstChunk = str.slice(0, 50);\n  // \"type\":\"xviz/*\"}\n  let lastChunk = str.slice(-50);\n\n  if (Number.isFinite(firstChunk[0])) {\n    firstChunk = String.fromCharCode.apply(null, firstChunk);\n    lastChunk = String.fromCharCode.apply(null, lastChunk);\n  }\n\n  return getXVIZType(firstChunk, lastChunk);\n}\n\n/* Javascript Object Support */\n\n// Returns the XVIZ message 'type' from the input string\n// else null if not found.\nexport function getObjectXVIZType(type) {\n  const match = type.match(XVIZ_TYPE_VALUE_PATTERN);\n  if (match) {\n    return match[0];\n  }\n\n  return null;\n}\n\n/* General XVIZ Message Support */\n\n// Efficiently check if an object is a supported XVIZ message, with minimal decoding.\n//\n// Returns the 'type' for the following formats:\n// - XVIZ binary (GLB)\n// - enveloped JSON object\n// - enveloped JSON string\n// - enveloped JSON string as arraybuffer\n//\n// else return null\nexport function getXVIZMessageType(data) {\n  switch (getDataContainer(data)) {\n    case 'binary':\n      if (isGLBXVIZ(data)) {\n        return getGLBXVIZType(data);\n      } else if (isPBEXVIZ(data)) {\n        return getPBEXVIZType(data);\n      }\n      if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      }\n      return getJSONXVIZType(data);\n\n    case 'string':\n      return getJSONXVIZType(data);\n\n    case 'object':\n      return data.type ? getObjectXVIZType(data.type) : null;\n\n    default:\n  }\n  return null;\n}\n\n// Efficiently check if an object is a supported XVIZ message, without decoding it.\n//\n// Returns true for the following formats:\n// - XVIZ binary (GLB)\n// - enveloped JSON object,\n// - enveloped JSON string\n// - enveloped JSON string as arraybuffer\n//\n// else return false\nexport function isXVIZMessage(data) {\n  switch (getDataContainer(data)) {\n    case 'binary':\n      if (isBinaryXVIZ(data)) {\n        return true;\n      }\n      if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      }\n      return getJSONXVIZType(data) !== null;\n\n    case 'string':\n      return getJSONXVIZType(data) !== null;\n\n    case 'object':\n      return data.type ? getObjectXVIZType(data.type) !== null : false;\n\n    default:\n  }\n  return false;\n}\n"],"file":"loaders.js"}