{"version":3,"sources":["../../../src/common/loaders.js"],"names":["XVIZ_TYPE_PATTERN","XVIZ_TYPE_VALUE_PATTERN","MAGIC_XVIZ","MAGIC_GLTF","LE","BE","GLB_FILE_HEADER_SIZE","GLB_CHUNK_HEADER_SIZE","getDataContainer","data","undefined","Buffer","ArrayBuffer","isView","getXVIZType","firstChunk","lastChunk","result","match","isEnvelope","type","unpackEnvelope","parts","split","namespace","slice","join","checkMagic","glbArrayBuffer","options","magic","magicAlt","dataView","DataView","magic1","getUint32","isBinaryXVIZ","arrayBuffer","isArrayBuffer","MAGIC_PBE1","parseBinaryXVIZ","opts","messageFormat","XVIZ_FORMAT","BINARY_PBE","parsePBEXVIZ","gltfParser","GLTFParser","parse","createImages","xviz","getApplicationData","getExtension","XVIZ_GLTF_EXTENSION","isGLBXVIZ","getGLBXVIZType","arraybuffer","jsonBuffer","getGLBXVIZJSONBuffer","textDecoder","TextDecoder","jsonString","decode","byteOffset","glb","version","byteLength","jsonChunkLength","jsonChunkFormat","GLB_CHUNK_TYPE_JSON","isJSONChunk","jsonChunkByteOffset","Uint8Array","isPBEXVIZ","getPBEXVIZType","strippedBuffer","envelope","XVIZ_PROTOBUF_MESSAGE","Envelope","toObject","String","postProcessUIConfig","msg","ui_config","Object","keys","entry","XVIZ_PROTOBUF_TYPE","UIPanelInfo","postProcessProtobuf","pbType","$type","fields","fieldName","field","name","resolvedType","repeated","length","Enum","map","valuesById","MapField","key","Type","messageType","value","tmpMeta","Metadata","tmpState","StateUpdate","Error","isJSONStringTypeArray","arr","firstChar","find","lastChars","from","lastChar","reverse","fromCharCode","isJSONString","str","beginning","trim","end","startsWith","endsWith","getJSONXVIZType","Number","isFinite","apply","getObjectXVIZType","getXVIZMessageType","isXVIZMessage"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* global Buffer */\nimport {GLTFParser} from '../gltf/gltf-parser';\n\nimport {XVIZ_FORMAT, XVIZ_GLTF_EXTENSION} from './constants';\nimport {TextDecoder} from './text-encoding';\nimport {MAGIC_PBE1, XVIZ_PROTOBUF_MESSAGE, XVIZ_PROTOBUF_TYPE} from './protobuf-support';\nimport {Enum, Type, MapField} from 'protobufjs';\n\n// XVIZ Type constants\nconst XVIZ_TYPE_PATTERN = /\"type\":\\s*\"(xviz\\/\\w*)\"/;\nconst XVIZ_TYPE_VALUE_PATTERN = /xviz\\/\\w*/;\n\n// GLB constants\nconst MAGIC_XVIZ = 0x5856495a; // XVIZ in Big-Endian ASCII\nconst MAGIC_GLTF = 0x676c5446; // glTF in Big-Endian ASCII\nconst LE = true; // Binary GLTF is little endian.\nconst BE = false; // Magic needs to be written as BE\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\n/* Data Format Support */\n\n// expected return value of null | binary | string | object\nexport function getDataContainer(data) {\n  if (data === null || data === undefined) {\n    return null;\n  }\n\n  if (data instanceof Buffer || data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    return 'binary';\n  }\n\n  // Cover string || object\n  return typeof data;\n}\n\n/* XVIZ Type Support */\n\n// Returns the XVIZ message 'type' from the input strings\n// else null if not found.\nfunction getXVIZType(firstChunk, lastChunk) {\n  let result = firstChunk.match(XVIZ_TYPE_PATTERN);\n  if (!result && lastChunk) {\n    result = lastChunk.match(XVIZ_TYPE_PATTERN);\n  }\n\n  if (result) {\n    // return the first match group which contains the type\n    return result[1];\n  }\n\n  return null;\n}\n\n/* Envelope Support */\n\n// Sniff out whether the JSON data provided is in the XVIZ envelope format\nexport function isEnvelope(data) {\n  return data.type && data.data;\n}\n\n// Parse apart the namespace and type for the enveloped data\nexport function unpackEnvelope(data) {\n  const parts = data.type.split('/');\n  return {\n    namespace: parts[0],\n    type: parts.slice(1).join('/'),\n    data: data.data\n  };\n}\n\n/* Binary Support */\n\n// Check first 4 bytes for a 'magic' value\nfunction checkMagic(glbArrayBuffer, options = {}) {\n  const {magic, magicAlt} = options;\n\n  // GLB Header\n  const dataView = new DataView(glbArrayBuffer);\n  const magic1 = dataView.getUint32(0, BE); // Magic number (the ASCII string 'glTF').\n\n  return magic1 === magic || (magicAlt && magicAlt === magic1);\n}\n\n// Supports GLB and Protobuf formats\nexport function isBinaryXVIZ(arrayBuffer) {\n  const isArrayBuffer = arrayBuffer instanceof ArrayBuffer;\n  return (\n    isArrayBuffer &&\n    (checkMagic(arrayBuffer, {magic: MAGIC_XVIZ, magicAlt: MAGIC_GLTF}) ||\n      checkMagic(arrayBuffer, {magic: MAGIC_PBE1}))\n  );\n}\n\n// Supports GLB and Protobuf formats\nexport function parseBinaryXVIZ(arrayBuffer, opts) {\n  if (\n    (opts && opts.messageFormat === XVIZ_FORMAT.BINARY_PBE) ||\n    checkMagic(arrayBuffer, {magic: MAGIC_PBE1})\n  ) {\n    return parsePBEXVIZ(arrayBuffer, opts);\n  }\n\n  const gltfParser = new GLTFParser();\n  gltfParser.parse(arrayBuffer, {createImages: false});\n\n  // TODO/ib - Fix when loaders.gl API is fixed\n  let xviz = gltfParser.getApplicationData('xviz');\n\n  if (xviz === undefined) {\n    xviz = gltfParser.getExtension(XVIZ_GLTF_EXTENSION);\n  }\n\n  return xviz;\n}\n\n/* GLB Support */\n\nexport function isGLBXVIZ(arrayBuffer) {\n  const isArrayBuffer = arrayBuffer instanceof ArrayBuffer;\n  // MAGIC_XVIZ is a deprecated magic header\n  return isArrayBuffer && checkMagic(arrayBuffer, {magic: MAGIC_XVIZ, magicAlt: MAGIC_GLTF});\n}\n\nfunction getGLBXVIZType(arraybuffer) {\n  const jsonBuffer = getGLBXVIZJSONBuffer(arraybuffer);\n  if (!jsonBuffer) {\n    return null;\n  }\n\n  // We have no choice but to decode the JSON portion of the buffer\n  // since it also contains all the GLB headers. This means we do not\n  // have any meaningful limits for where to search for the 'type' string\n  const textDecoder = new TextDecoder('utf8');\n  const jsonString = textDecoder.decode(jsonBuffer);\n\n  return getXVIZType(jsonString);\n}\n\n// Mostly taken from @loaders.gltf parse-glb.js, but limited to just getting the json chunk\n// as we do not need to parse the binary here.\nfunction getGLBXVIZJSONBuffer(arrayBuffer, byteOffset = 0) {\n  // GLB Header\n  const dataView = new DataView(arrayBuffer);\n  const glb = {};\n\n  glb.byteOffset = byteOffset; // Byte offset into the initial arrayBuffer\n\n  // GLB Header\n  glb.magic = dataView.getUint32(byteOffset + 0, BE); // Magic number (the ASCII string 'glTF').\n  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  glb.byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of generated file\n\n  if (glb.version !== 2 || glb.byteLength < 20) {\n    return null;\n  }\n\n  glb.jsonChunkLength = dataView.getUint32(byteOffset + 12, LE); // Byte length of json chunk\n  glb.jsonChunkFormat = dataView.getUint32(byteOffset + 16, LE); // Chunk format as uint32\n\n  const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\n  const isJSONChunk = glb.jsonChunkFormat === GLB_CHUNK_TYPE_JSON || glb.jsonChunkFormat === 0;\n\n  if (!isJSONChunk) {\n    // JSON should be first and present\n    return null;\n  }\n\n  glb.jsonChunkByteOffset = GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE; // First headers: 20 bytes\n  return new Uint8Array(arrayBuffer, byteOffset + glb.jsonChunkByteOffset, glb.jsonChunkLength);\n}\n\n/* Protobuf Support */\n\nexport function isPBEXVIZ(arrayBuffer) {\n  const isArrayBuffer = arrayBuffer instanceof ArrayBuffer;\n  return isArrayBuffer && checkMagic(arrayBuffer, {magic: MAGIC_PBE1});\n}\n\nfunction getPBEXVIZType(arrayBuffer) {\n  const strippedBuffer = new Uint8Array(arrayBuffer, 4);\n  // TODO: this toObject is too expensive, we can do\n  // this with decode only\n  const envelope = XVIZ_PROTOBUF_MESSAGE.Envelope.toObject(strippedBuffer, {\n    enum: String\n  });\n\n  return envelope.type;\n}\n\nfunction postProcessUIConfig(msg) {\n  if (msg && msg.ui_config) {\n    for (const entry of Object.keys(msg.ui_config)) {\n      msg.ui_config[entry] = XVIZ_PROTOBUF_TYPE.UIPanelInfo.toObject(msg.ui_config[entry]);\n    }\n  }\n}\n\n/* We need to modify the protobufjs objects to work closer to \"normal\"\n * Javascript objects. The protobuf type reflection is available as `msg.$type`\n * which is traversed in parallel to the `msg`.\n *\n * The following mutations are made:\n *\n * - Remove empty Arrays from the instance, protobuf.js will set to the default value: [] (the empty array)\n * - Enum => String\n * - Handle arrays of enum\n * - Recursive on objects\n */\n/* eslint-disable max-depth, complexity */\nfunction postProcessProtobuf(msg, pbType) {\n  const type = pbType || msg.$type;\n\n  if (msg && type && type.fields) {\n    const fields = type.fields;\n\n    for (const fieldName in fields) {\n      const field = fields[fieldName];\n\n      if (field && msg[field.name]) {\n        if (!field.resolvedType && field.repeated && msg[field.name].length === 0) {\n          // Remove empty arrays that are likely the default value\n          msg[field.name] = undefined;\n          delete msg[field.name];\n        } else if (field.resolvedType) {\n          // Handle integer enum to string change\n          if (field.resolvedType instanceof Enum) {\n            if (field.repeated) {\n              if (msg[field.name].length === 0) {\n                // Remove empty arrays that are likely the default value\n                msg[field.name] = undefined;\n                delete msg[field.name];\n              } else {\n                // Map array of enums to strings using reflection information\n                msg[field.name] = msg[field.name].map(\n                  entry => field.resolvedType.valuesById[entry]\n                );\n              }\n            } else {\n              // Map enums to strings using reflection information\n              msg[field.name] = field.resolvedType.valuesById[msg[field.name]];\n            }\n          } else if (field instanceof MapField) {\n            // Recursive processing on key,value field\n            for (const key of Object.keys(msg[field.name])) {\n              msg[field.name][key] = postProcessProtobuf(msg[field.name][key], field.resolvedType);\n            }\n          } else if (field.resolvedType instanceof Type) {\n            // Recursive processing on fields of an object\n            if (field.repeated) {\n              if (msg[field.name].length === 0) {\n                msg[field.name] = undefined;\n                delete msg[field.name];\n              } else {\n                msg[field.name] = msg[field.name].map(entry =>\n                  postProcessProtobuf(entry, field.resolvedType)\n                );\n              }\n            } else {\n              msg[field.name] = postProcessProtobuf(msg[field.name], field.resolvedType);\n            }\n          }\n        }\n      }\n    }\n  }\n  return msg;\n}\n/* eslint-enable max-depth, complexity */\n\n// TODO: unpackEnvelop produces namespace, type data\n// Handle PBE and raw protobuf messages if opts.messageType is supplied\nexport function parsePBEXVIZ(arrayBuffer, opts = {}) {\n  const {messageType} = opts;\n  const xviz = {\n    type: messageType,\n    data: null\n  };\n\n  let data = arrayBuffer;\n\n  // If the type has been provided, it means there is no Envelope so skip that step\n  if (!xviz.type) {\n    const strippedBuffer = new Uint8Array(arrayBuffer, 4);\n    const envelope = XVIZ_PROTOBUF_MESSAGE.Envelope.decode(strippedBuffer);\n    xviz.type = envelope.type;\n    data = envelope.data.value;\n  }\n\n  switch (xviz.type) {\n    case 'xviz/metadata':\n      const tmpMeta = XVIZ_PROTOBUF_MESSAGE.Metadata.decode(data);\n      xviz.data = postProcessProtobuf(tmpMeta);\n      postProcessUIConfig(xviz.data);\n      break;\n    case 'xviz/state_update':\n      const tmpState = XVIZ_PROTOBUF_MESSAGE.StateUpdate.decode(data);\n      xviz.data = postProcessProtobuf(tmpState);\n      break;\n    default:\n      throw new Error(`Unknown Message type ${xviz.type}`);\n  }\n\n  return xviz;\n}\n\n/* JSON Support */\n\n// Return true if the ArrayBuffer represents a JSON string.\n//\n// Search the first and last 5 entries for evidence of\n// being a JSON buffer\nfunction isJSONStringTypeArray(arr) {\n  let firstChar = arr.slice(0, 5).find(entry => entry >= 0x20);\n  let lastChars = arr.slice(-5);\n\n  // Buffer.slice() does not make a copy, but we need one since\n  // we call reverse()\n  if (lastChars instanceof Buffer) {\n    lastChars = Buffer.from(lastChars);\n  }\n\n  let lastChar = lastChars.reverse().find(entry => entry >= 0x20);\n\n  firstChar = String.fromCharCode(firstChar);\n  lastChar = String.fromCharCode(lastChar);\n\n  return (firstChar === '{' && lastChar === '}') || (firstChar === '[' && lastChar === ']');\n}\n\n// returns true if the input represents a JSON string.\n// Can be either string or Uint8Array\n//\n// Search the first and last 5 entries for evidence of\n// being a JSON buffer\nexport function isJSONString(str) {\n  if (str instanceof Uint8Array) {\n    return isJSONStringTypeArray(str);\n  }\n\n  if (typeof str === 'object') {\n    return false;\n  }\n\n  const beginning = str.slice(0, 5).trim();\n  const end = str.slice(-5).trim();\n\n  return (\n    (beginning.startsWith('{') && end.endsWith('}')) ||\n    (beginning.startsWith('[') && end.endsWith(']'))\n  );\n}\n\n// return the XVIZ type string if the input represents an enveloped XVIZ\n// object as a JSON string.\n// 'str' can be either string or Uint8Array\nfunction getJSONXVIZType(str) {\n  // We are trying to capture\n  // \"type\"\\s*:\\s*\"xviz/transform_point_in_time\"\n  // which the smallest is 37 bytes. Grab 50\n  // to provide room for spacing\n\n  // {\"type\":\"xviz/*\"\n  let firstChunk = str.slice(0, 50);\n  // \"type\":\"xviz/*\"}\n  let lastChunk = str.slice(-50);\n\n  if (Number.isFinite(firstChunk[0])) {\n    firstChunk = String.fromCharCode.apply(null, firstChunk);\n    lastChunk = String.fromCharCode.apply(null, lastChunk);\n  }\n\n  return getXVIZType(firstChunk, lastChunk);\n}\n\n/* Javascript Object Support */\n\n// Returns the XVIZ message 'type' from the input string\n// else null if not found.\nexport function getObjectXVIZType(type) {\n  const match = type.match(XVIZ_TYPE_VALUE_PATTERN);\n  if (match) {\n    return match[0];\n  }\n\n  return null;\n}\n\n/* General XVIZ Message Support */\n\n// Efficiently check if an object is a supported XVIZ message, with minimal decoding.\n//\n// Returns the 'type' for the following formats:\n// - XVIZ binary (GLB)\n// - enveloped JSON object\n// - enveloped JSON string\n// - enveloped JSON string as arraybuffer\n//\n// else return null\nexport function getXVIZMessageType(data) {\n  switch (getDataContainer(data)) {\n    case 'binary':\n      if (isGLBXVIZ(data)) {\n        return getGLBXVIZType(data);\n      } else if (isPBEXVIZ(data)) {\n        return getPBEXVIZType(data);\n      }\n      if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      }\n      return getJSONXVIZType(data);\n\n    case 'string':\n      return getJSONXVIZType(data);\n\n    case 'object':\n      return data.type ? getObjectXVIZType(data.type) : null;\n\n    default:\n  }\n  return null;\n}\n\n// Efficiently check if an object is a supported XVIZ message, without decoding it.\n//\n// Returns true for the following formats:\n// - XVIZ binary (GLB)\n// - enveloped JSON object,\n// - enveloped JSON string\n// - enveloped JSON string as arraybuffer\n//\n// else return false\nexport function isXVIZMessage(data) {\n  switch (getDataContainer(data)) {\n    case 'binary':\n      if (isBinaryXVIZ(data)) {\n        return true;\n      }\n      if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      }\n      return getJSONXVIZType(data) !== null;\n\n    case 'string':\n      return getJSONXVIZType(data) !== null;\n\n    case 'object':\n      return data.type ? getObjectXVIZType(data.type) !== null : false;\n\n    default:\n  }\n  return false;\n}\n"],"file":"loaders.js"}