{"version":3,"sources":["../../../src/utils/get-image-size.js"],"names":["mimeTypeMap","Map","getPngSize","getJpegSize","getGifSize","getBmpSize","getImageSize","contents","mimeType","ERR_INVALID_TYPE","Array","from","keys","join","handler","get","Error","result","entries","supportedMimeType","readUInt32BE","width","height","readUInt16BE","getJpegMarkers","tableMarkers","sofMarkers","i","length","marker","has","Set","add","readUInt16LE","readUInt32LE"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\nconst mimeTypeMap = new Map([\n  ['image/png', getPngSize],\n  ['image/jpeg', getJpegSize],\n  ['image/gif', getGifSize],\n  ['image/bmp', getBmpSize]\n]);\n\n/**\n * Sniffs the contents of a file to attempt to deduce the image type and extract image size.\n * Supported image types are PNG, JPEG, GIF and BMP.\n *\n * @param {Buffer} contents\n * @param {string} [mimeType]\n */\nexport function getImageSize(contents, mimeType) {\n  const ERR_INVALID_TYPE = `Invalid MIME type. Supported MIME types are: ${Array.from(\n    mimeTypeMap.keys()\n  ).join(', ')}`;\n\n  // Looking for only a specific MIME type.\n  if (mimeType) {\n    const handler = mimeTypeMap.get(mimeType);\n    if (!handler) {\n      throw new Error(ERR_INVALID_TYPE);\n    }\n\n    const result = handler(contents);\n    if (!result) {\n      throw new Error(`invalid image data for type: ${mimeType}`);\n    }\n    return result;\n  }\n\n  // Loop through each file type and see if they work.\n  for (const [supportedMimeType, handler] of mimeTypeMap.entries()) {\n    const result = handler(contents);\n    if (result) {\n      result.mimeType = supportedMimeType;\n      return result;\n    }\n  }\n\n  // Seems not :(\n  throw new Error(ERR_INVALID_TYPE);\n}\n\n/**\n * Extract size from a binary PNG file\n * @param {Buffer} contents\n */\nfunction getPngSize(contents) {\n  // Check file contains the first 4 bytes of the PNG signature.\n  if (contents.readUInt32BE(0) !== 0x89504e47) {\n    return null;\n  }\n\n  const width = contents.readUInt32BE(16);\n  const height = contents.readUInt32BE(20);\n  return {width, height};\n}\n\n/**\n * Extract size from a binary JPEG file\n * @param {Buffer} contents\n */\nfunction getJpegSize(contents) {\n  // Check file contains the JPEG \"start of image\" (SOI) marker.\n  if (contents.readUInt16BE(0) !== 0xffd8) {\n    return null;\n  }\n\n  const {tableMarkers, sofMarkers} = getJpegMarkers();\n\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i < contents.length) {\n    const marker = contents.readUInt16BE(i);\n\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      // Number of lines.\n      const height = contents.readUInt16BE(i + 5);\n      // Number of pixels per line.\n      const width = contents.readUInt16BE(i + 7);\n      return {width, height};\n    }\n\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += contents.readUInt16BE(i);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([\n    0xffc0,\n    0xffc1,\n    0xffc2,\n    0xffc3,\n    0xffc5,\n    0xffc6,\n    0xffc7,\n    0xffc9,\n    0xffca,\n    0xffcb,\n    0xffcd,\n    0xffce,\n    0xffcf,\n    0xffde\n  ]);\n\n  return {tableMarkers, sofMarkers};\n}\n\n/**\n * Extract size from a binary GIF file\n * @param {Buffer} contents\n * TODO: GIF is not this simple\n */\nfunction getGifSize(contents) {\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  if (contents.readUInt32BE(0) !== 0x47494638) {\n    return null;\n  }\n\n  // GIF is little endian.\n  const width = contents.readUInt16LE(6);\n  const height = contents.readUInt16LE(8);\n  return {width, height};\n}\n\n/**\n * @param {Buffer} contents\n * TODO: BMP is not this simple\n */\nfunction getBmpSize(contents) {\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  if (contents.readUInt16BE(0) !== 0x424d) {\n    return null;\n  }\n\n  // BMP is little endian.\n  const width = contents.readUInt32LE(18);\n  const height = contents.readUInt32LE(22);\n  return {width, height};\n}\n"],"file":"get-image-size.js"}