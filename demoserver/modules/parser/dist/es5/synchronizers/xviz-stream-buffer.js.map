{"version":3,"sources":["../../../src/synchronizers/xviz-stream-buffer.js"],"names":["LEFT","INSERT_POSITION","RIGHT","UNLIMITED","OFFSET","FIXED","XVIZStreamBuffer","startOffset","endOffset","maxLength","Number","isFinite","bufferType","options","bufferStart","bufferEnd","timeslices","persistent","streams","videos","persistentStreams","lastUpdate","streamCount","hasBuffer","bind","start","end","Math","min","_pruneBuffer","oldStart","oldEnd","len","length","timestamp","startIndex","_indexOf","endIndex","persistentEndIndex","slice","concat","result","streamName","filter","value","undefined","map","t","vehiclePose","Boolean","timeslice","updateType","isInBufferRange","links","_insertPersistentSlice","Array","insertPosition","timesliceAtInsertPosition","_insertTimesliceAt","_mergeTimesliceAt","fromTime","toTime","getLoadedTimeRange","XVIZObject","prune","trimStart","trimEnd","splice","stream","persistentSlice","index","Object","assign","deleteCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport XVIZObject from '../objects/xviz-object';\nimport assert from '../utils/assert';\nimport {findInsertPos, INSERT_POSITION} from '../utils/search';\n\n// Insert positions\nconst LEFT = INSERT_POSITION.LEFT;\nconst RIGHT = INSERT_POSITION.RIGHT;\n\n// Buffer types\nconst UNLIMITED = 0;\nconst OFFSET = 1;\nconst FIXED = 2;\n\nexport default class XVIZStreamBuffer {\n  /**\n   * constructor\n   * @param {object} options\n   * @param {number} options.startOffset - desired start of buffer to keep in memory\n   *  relative to the current time.\n   * @param {number} options.endOffset - desired end of buffer to keep in memory\n   *  relative to the current time.\n   */\n  constructor({startOffset = null, endOffset = null, maxLength = null} = {}) {\n    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {\n      assert(startOffset <= 0 && endOffset >= 0, 'Steam buffer offset');\n      this.bufferType = OFFSET;\n    } else {\n      this.bufferType = UNLIMITED;\n    }\n\n    this.options = {\n      startOffset,\n      endOffset,\n      maxLength\n    };\n\n    /* Desired buffer range, in timestamps */\n    this.bufferStart = null;\n    this.bufferEnd = null;\n    /* Sorted timeslices */\n    this.timeslices = [];\n    this.persistent = []; // like timeslices, but never pruned\n    /* Sorted values by stream */\n    this.streams = {};\n    this.videos = {};\n    this.persistentStreams = {};\n    /* Update counter */\n    this.lastUpdate = 0;\n    /* Track the number of unique streams */\n    this.streamCount = 0;\n\n    this.hasBuffer = this.hasBuffer.bind(this);\n  }\n\n  /**\n   * @property {number} the count of timeslices in buffer\n   */\n  get size() {\n    return this.timeslices.length + this.persistent.length;\n  }\n\n  /**\n   * updates the fixed buffer range, capping it to maxLength if set\n   * @param {number} start - desired fixed start time of buffer to keep in memory\n   * @param {number} end - desired fixed end time of buffer to keep in memory\n   * @returns {start: number, end: number, oldStart: number, oldEnd: number} - the old and new buffer ranges\n   */\n  updateFixedBuffer(start, end) {\n    const {\n      bufferStart,\n      bufferEnd,\n      options: {maxLength}\n    } = this;\n    assert(start < end, 'updateFixedBuffer start / end');\n    assert(\n      this.bufferType === UNLIMITED || this.bufferType === FIXED,\n      'updateFixedBuffer multiple buffer types'\n    );\n    this.bufferType = FIXED;\n\n    if (!maxLength) {\n      // If we have no limits on buffer size, just use the new provided values\n      this.bufferStart = start;\n      this.bufferEnd = end;\n    } else if (\n      !Number.isFinite(bufferStart) ||\n      start > bufferEnd + maxLength ||\n      start < bufferStart - maxLength\n    ) {\n      // If we have a limit but this is our first range definition, or this is so far before the existing\n      // buffer that there's no overlap, use the provided start and determine end based on max buffer length\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(end, start + maxLength);\n    } else if (start < bufferStart) {\n      // If this is before the existing buffer but close enough to have overlap, use the provided start\n      // and determine the end based on max buffer length and the existing buffer end\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(bufferEnd, start + maxLength);\n    } else {\n      // Otherwise, we're past the end of the existing buffer and either extend the existing buffer\n      // or start a new buffer based on maxLength\n      this.bufferStart = Math.min(bufferEnd, end - maxLength);\n      this.bufferEnd = Math.min(this.bufferStart + maxLength, end);\n    }\n    this._pruneBuffer();\n    return {start: this.bufferStart, end: this.bufferEnd, oldStart: bufferStart, oldEnd: bufferEnd};\n  }\n\n  /**\n   * Gets the time range that the buffer is accepting data for\n   * @returns {object} - {start | null, end | null} timestamps if any timeslice is loaded\n   */\n  getBufferRange() {\n    if (this.bufferType !== UNLIMITED) {\n      const {bufferStart, bufferEnd} = this;\n      if (Number.isFinite(bufferStart)) {\n        // buffer range should be ignored if setCurrentTime has not been called\n        return {start: bufferStart, end: bufferEnd};\n      }\n    }\n    return {start: null, end: null};\n  }\n\n  /**\n   * Gets the buffered time range\n   * @returns {object | null} - {start, end} timestamps if any timeslice is loaded\n   */\n  getLoadedTimeRange() {\n    // TODO what about persistent?\n    const {timeslices} = this;\n    const len = timeslices.length;\n\n    if (len > 0) {\n      return {\n        start: timeslices[0].timestamp,\n        end: timeslices[len - 1].timestamp\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Gets timeslices within a given time range.\n   * @params {number, optional} start - start timestamp (inclusive)\n   * @params {number, optional} end - end timestamp (inclusive)\n   * @returns {array} - loaded timeslices within range\n   */\n  getTimeslices({start, end} = {}) {\n    const {timeslices, persistent} = this;\n    const startIndex = Number.isFinite(start) ? this._indexOf(start, LEFT) : 0;\n    const endIndex = Number.isFinite(end) ? this._indexOf(end, RIGHT) : timeslices.length;\n    const persistentEndIndex = Number.isFinite(end)\n      ? findInsertPos(persistent, end, RIGHT)\n      : persistent.length;\n\n    return persistent.slice(0, persistentEndIndex).concat(timeslices.slice(startIndex, endIndex));\n  }\n\n  /**\n   * Deprecated for perf reasons\n   * Gets loaded stream slices within the current buffer\n   */\n  getStreams() {\n    const {streams} = this;\n    const result = {};\n    for (const streamName in streams) {\n      result[streamName] = streams[streamName].filter(value => value !== undefined);\n    }\n    return result;\n  }\n\n  /**\n   * Gets loaded video frames within the current buffer\n   */\n  getVideos() {\n    const {videos} = this;\n    const result = {};\n    for (const streamName in videos) {\n      result[streamName] = videos[streamName].filter(value => value !== undefined);\n    }\n    return result;\n  }\n\n  /**\n   * Get vehicle poses within the current buffer\n   */\n  getVehiclePoses() {\n    return this.timeslices.map(t => t.vehiclePose).filter(Boolean);\n  }\n\n  /**\n   * Add a new timeslice object into the timeline\n   * @params {object} timeslice - timeslice object from XVIZ stream\n   */\n  // eslint-disable-next-line complexity, max-statements\n  insert(timeslice) {\n    const {timestamp, updateType} = timeslice;\n\n    if (!this.isInBufferRange(timestamp)) {\n      return false;\n    }\n\n    // backwards compatibility - normalize time slice\n    timeslice.streams = timeslice.streams || {};\n    timeslice.videos = timeslice.videos || {};\n    timeslice.links = timeslice.links || {};\n\n    const {timeslices, streams, videos} = this;\n\n    if (updateType === 'PERSISTENT') {\n      this._insertPersistentSlice(timeslice);\n      this.lastUpdate++;\n      return true;\n    }\n\n    // Note: if stream is not present in a timeslice, that index in the list holds undefined\n    // This avoids repeatedly allocating new arrays for each stream, and lowers the cost of\n    // insertion/deletion, which can be a significant perf hit depending on frame rate and\n    // buffer size.\n    for (const streamName in timeslice.streams) {\n      if (!streams[streamName]) {\n        streams[streamName] = new Array(timeslices.length);\n        this.streamCount++;\n      }\n    }\n    for (const streamName in timeslice.videos) {\n      if (!videos[streamName]) {\n        videos[streamName] = new Array(timeslices.length);\n      }\n    }\n\n    const insertPosition = this._indexOf(timestamp, LEFT);\n    const timesliceAtInsertPosition = timeslices[insertPosition];\n\n    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {\n      // Same timestamp\n      if (updateType === 'COMPLETE') {\n        // Replace if it's a complete state\n        this._insertTimesliceAt(insertPosition, 1, timeslice);\n      } else {\n        // Merge if it's an incremental update (default)\n        this._mergeTimesliceAt(insertPosition, timeslice);\n      }\n    } else {\n      this._insertTimesliceAt(insertPosition, 0, timeslice);\n    }\n\n    this.lastUpdate++;\n    return true;\n  }\n\n  /**\n   * Set the current timestamp\n   * May drop timeslices that are not in range\n   * @params {number} timestamp - timestamp of the playhead\n   */\n  setCurrentTime(timestamp) {\n    if (this.bufferType === OFFSET) {\n      const {\n        options: {startOffset, endOffset}\n      } = this;\n      this.bufferStart = timestamp + startOffset;\n      this.bufferEnd = timestamp + endOffset;\n      this._pruneBuffer();\n    }\n  }\n\n  /**\n   * Override Object.prototype.valueOf\n   * This is used to trigger a selector update without creating a new XVIZStreamBuffer instance\n   */\n  valueOf() {\n    return this.lastUpdate;\n  }\n\n  /**\n   * Provide interface for video-synchronizer to test for valid gps-based time range data.\n   *\n   * @params {number} fromTime is the gps time start of data\n   * @params {number} toTime is the gps time end of data\n   * @returns {bool} If we have no data, always return true, else true is returned\n   *                 if the time range is satisfied\n   */\n  hasBuffer(fromTime, toTime) {\n    // TODO: persistent\n    if (!this.timeslices.length) {\n      return true;\n    }\n    const {start, end} = this.getLoadedTimeRange();\n    return fromTime >= start && toTime <= end;\n  }\n\n  /**\n   * Check if a timestamp is inside the desired buffer range\n   * @params {number} timestamp\n   * @returns {bool}\n   */\n  isInBufferRange(timestamp) {\n    const {bufferStart, bufferEnd, bufferType} = this;\n    if (bufferType !== UNLIMITED && Number.isFinite(bufferStart)) {\n      return timestamp >= bufferStart && timestamp <= bufferEnd;\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, no-unused-expressions */\n  _pruneBuffer() {\n    const {timeslices, streams, videos} = this;\n\n    if (timeslices.length) {\n      const startIndex = this._indexOf(this.bufferStart, LEFT);\n      const endIndex = this._indexOf(this.bufferEnd, RIGHT);\n\n      XVIZObject.prune(this.bufferStart, this.bufferEnd);\n\n      const trimStart = startIndex > 0;\n      const trimEnd = endIndex < timeslices.length;\n      if (trimStart || trimEnd) {\n        // Drop frames that are outside of the buffer\n        trimEnd && timeslices.splice(endIndex);\n        trimStart && timeslices.splice(0, startIndex);\n\n        for (const streamName in streams) {\n          const stream = streams[streamName];\n          trimEnd && stream.splice(endIndex);\n          trimStart && stream.splice(0, startIndex);\n        }\n        for (const streamName in videos) {\n          const stream = videos[streamName];\n          trimEnd && stream.splice(endIndex);\n          trimStart && stream.splice(0, startIndex);\n        }\n\n        this.lastUpdate++;\n      }\n    }\n  }\n  /* eslint-enable complexity, no-unused-expressions */\n\n  _insertPersistentSlice(persistentSlice) {\n    const {persistent, persistentStreams} = this;\n    const {timestamp, streams, links} = persistentSlice;\n    const index = findInsertPos(persistent, timestamp, LEFT);\n    const timesliceAtInsertPosition = persistent[index];\n\n    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {\n      // merge\n      Object.assign(timesliceAtInsertPosition, persistentSlice, {\n        streams: Object.assign(timesliceAtInsertPosition.streams, streams),\n        links: Object.assign(timesliceAtInsertPosition.links, links)\n      });\n    } else {\n      // insert\n      persistent.splice(index, 0, persistentSlice);\n    }\n\n    for (const streamName in streams) {\n      if (!(streamName in persistentStreams)) {\n        persistentStreams[streamName] = true;\n        this.streamCount++;\n      }\n    }\n  }\n\n  _mergeTimesliceAt(index, timeslice) {\n    const {timeslices, streams, videos} = this;\n    const timesliceAtInsertPosition = timeslices[index];\n\n    Object.assign(timesliceAtInsertPosition, timeslice, {\n      streams: Object.assign(timesliceAtInsertPosition.streams, timeslice.streams),\n      links: Object.assign(timesliceAtInsertPosition.links, timeslice.links),\n      videos: Object.assign(timesliceAtInsertPosition.videos, timeslice.videos)\n    });\n\n    for (const streamName in timeslice.streams) {\n      const value = timeslice.streams[streamName];\n      streams[streamName][index] = value;\n    }\n    for (const streamName in timeslice.videos) {\n      videos[streamName][index] = timeslice.videos[streamName];\n    }\n  }\n\n  _insertTimesliceAt(index, deleteCount, timeslice) {\n    const {timeslices, streams, videos} = this;\n\n    timeslices.splice(index, deleteCount, timeslice);\n\n    for (const streamName in streams) {\n      streams[streamName].splice(index, deleteCount, timeslice.streams[streamName]);\n    }\n\n    for (const streamName in videos) {\n      videos[streamName].splice(index, deleteCount, timeslice.videos[streamName]);\n    }\n  }\n\n  /**\n   * Return insert position for timeslice data given a timestamp\n   * @params {number} timestamp\n   * @params {number} insertPosition - insert to the left or right of the equal element.\n   * @returns {number} index of insert position\n   */\n  _indexOf(timestamp, insertPosition = LEFT) {\n    const {timeslices} = this;\n    return findInsertPos(timeslices, timestamp, insertPosition);\n  }\n}\n"],"file":"xviz-stream-buffer.js"}