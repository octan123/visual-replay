{"version":3,"sources":["../../../src/synchronizers/xviz-stream-buffer.js"],"names":["XVIZObject","assert","findInsertPos","INSERT_POSITION","LEFT","RIGHT","UNLIMITED","OFFSET","FIXED","XVIZStreamBuffer","constructor","startOffset","endOffset","maxLength","Number","isFinite","bufferType","options","bufferStart","bufferEnd","timeslices","persistent","streams","videos","persistentStreams","lastUpdate","streamCount","hasBuffer","bind","size","length","updateFixedBuffer","start","end","Math","min","_pruneBuffer","oldStart","oldEnd","getBufferRange","getLoadedTimeRange","len","timestamp","getTimeslices","startIndex","_indexOf","endIndex","persistentEndIndex","slice","concat","getStreams","result","streamName","filter","value","undefined","getVideos","getVehiclePoses","map","t","vehiclePose","Boolean","insert","timeslice","updateType","isInBufferRange","links","_insertPersistentSlice","Array","insertPosition","timesliceAtInsertPosition","_insertTimesliceAt","_mergeTimesliceAt","setCurrentTime","valueOf","fromTime","toTime","prune","trimStart","trimEnd","splice","stream","persistentSlice","index","Object","assign","deleteCount"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport XVIZObject from '../objects/xviz-object';\nimport assert from '../utils/assert';\nimport {findInsertPos, INSERT_POSITION} from '../utils/search';\n\n// Insert positions\nconst LEFT = INSERT_POSITION.LEFT;\nconst RIGHT = INSERT_POSITION.RIGHT;\n\n// Buffer types\nconst UNLIMITED = 0;\nconst OFFSET = 1;\nconst FIXED = 2;\n\nexport default class XVIZStreamBuffer {\n  /**\n   * constructor\n   * @param {object} options\n   * @param {number} options.startOffset - desired start of buffer to keep in memory\n   *  relative to the current time.\n   * @param {number} options.endOffset - desired end of buffer to keep in memory\n   *  relative to the current time.\n   */\n  constructor({startOffset = null, endOffset = null, maxLength = null} = {}) {\n    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {\n      assert(startOffset <= 0 && endOffset >= 0, 'Steam buffer offset');\n      this.bufferType = OFFSET;\n    } else {\n      this.bufferType = UNLIMITED;\n    }\n\n    this.options = {\n      startOffset,\n      endOffset,\n      maxLength\n    };\n\n    /* Desired buffer range, in timestamps */\n    this.bufferStart = null;\n    this.bufferEnd = null;\n    /* Sorted timeslices */\n    this.timeslices = [];\n    this.persistent = []; // like timeslices, but never pruned\n    /* Sorted values by stream */\n    this.streams = {};\n    this.videos = {};\n    this.persistentStreams = {};\n    /* Update counter */\n    this.lastUpdate = 0;\n    /* Track the number of unique streams */\n    this.streamCount = 0;\n\n    this.hasBuffer = this.hasBuffer.bind(this);\n  }\n\n  /**\n   * @property {number} the count of timeslices in buffer\n   */\n  get size() {\n    return this.timeslices.length + this.persistent.length;\n  }\n\n  /**\n   * updates the fixed buffer range, capping it to maxLength if set\n   * @param {number} start - desired fixed start time of buffer to keep in memory\n   * @param {number} end - desired fixed end time of buffer to keep in memory\n   * @returns {start: number, end: number, oldStart: number, oldEnd: number} - the old and new buffer ranges\n   */\n  updateFixedBuffer(start, end) {\n    const {\n      bufferStart,\n      bufferEnd,\n      options: {maxLength}\n    } = this;\n    assert(start < end, 'updateFixedBuffer start / end');\n    assert(\n      this.bufferType === UNLIMITED || this.bufferType === FIXED,\n      'updateFixedBuffer multiple buffer types'\n    );\n    this.bufferType = FIXED;\n\n    if (!maxLength) {\n      // If we have no limits on buffer size, just use the new provided values\n      this.bufferStart = start;\n      this.bufferEnd = end;\n    } else if (\n      !Number.isFinite(bufferStart) ||\n      start > bufferEnd + maxLength ||\n      start < bufferStart - maxLength\n    ) {\n      // If we have a limit but this is our first range definition, or this is so far before the existing\n      // buffer that there's no overlap, use the provided start and determine end based on max buffer length\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(end, start + maxLength);\n    } else if (start < bufferStart) {\n      // If this is before the existing buffer but close enough to have overlap, use the provided start\n      // and determine the end based on max buffer length and the existing buffer end\n      this.bufferStart = start;\n      this.bufferEnd = Math.min(bufferEnd, start + maxLength);\n    } else {\n      // Otherwise, we're past the end of the existing buffer and either extend the existing buffer\n      // or start a new buffer based on maxLength\n      this.bufferStart = Math.min(bufferEnd, end - maxLength);\n      this.bufferEnd = Math.min(this.bufferStart + maxLength, end);\n    }\n    this._pruneBuffer();\n    return {start: this.bufferStart, end: this.bufferEnd, oldStart: bufferStart, oldEnd: bufferEnd};\n  }\n\n  /**\n   * Gets the time range that the buffer is accepting data for\n   * @returns {object} - {start | null, end | null} timestamps if any timeslice is loaded\n   */\n  getBufferRange() {\n    if (this.bufferType !== UNLIMITED) {\n      const {bufferStart, bufferEnd} = this;\n      if (Number.isFinite(bufferStart)) {\n        // buffer range should be ignored if setCurrentTime has not been called\n        return {start: bufferStart, end: bufferEnd};\n      }\n    }\n    return {start: null, end: null};\n  }\n\n  /**\n   * Gets the buffered time range\n   * @returns {object | null} - {start, end} timestamps if any timeslice is loaded\n   */\n  getLoadedTimeRange() {\n    // TODO what about persistent?\n    const {timeslices} = this;\n    const len = timeslices.length;\n\n    if (len > 0) {\n      return {\n        start: timeslices[0].timestamp,\n        end: timeslices[len - 1].timestamp\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Gets timeslices within a given time range.\n   * @params {number, optional} start - start timestamp (inclusive)\n   * @params {number, optional} end - end timestamp (inclusive)\n   * @returns {array} - loaded timeslices within range\n   */\n  getTimeslices({start, end} = {}) {\n    const {timeslices, persistent} = this;\n    const startIndex = Number.isFinite(start) ? this._indexOf(start, LEFT) : 0;\n    const endIndex = Number.isFinite(end) ? this._indexOf(end, RIGHT) : timeslices.length;\n    const persistentEndIndex = Number.isFinite(end)\n      ? findInsertPos(persistent, end, RIGHT)\n      : persistent.length;\n\n    return persistent.slice(0, persistentEndIndex).concat(timeslices.slice(startIndex, endIndex));\n  }\n\n  /**\n   * Deprecated for perf reasons\n   * Gets loaded stream slices within the current buffer\n   */\n  getStreams() {\n    const {streams} = this;\n    const result = {};\n    for (const streamName in streams) {\n      result[streamName] = streams[streamName].filter(value => value !== undefined);\n    }\n    return result;\n  }\n\n  /**\n   * Gets loaded video frames within the current buffer\n   */\n  getVideos() {\n    const {videos} = this;\n    const result = {};\n    for (const streamName in videos) {\n      result[streamName] = videos[streamName].filter(value => value !== undefined);\n    }\n    return result;\n  }\n\n  /**\n   * Get vehicle poses within the current buffer\n   */\n  getVehiclePoses() {\n    return this.timeslices.map(t => t.vehiclePose).filter(Boolean);\n  }\n\n  /**\n   * Add a new timeslice object into the timeline\n   * @params {object} timeslice - timeslice object from XVIZ stream\n   */\n  // eslint-disable-next-line complexity, max-statements\n  insert(timeslice) {\n    const {timestamp, updateType} = timeslice;\n\n    if (!this.isInBufferRange(timestamp)) {\n      return false;\n    }\n\n    // backwards compatibility - normalize time slice\n    timeslice.streams = timeslice.streams || {};\n    timeslice.videos = timeslice.videos || {};\n    timeslice.links = timeslice.links || {};\n\n    const {timeslices, streams, videos} = this;\n\n    if (updateType === 'PERSISTENT') {\n      this._insertPersistentSlice(timeslice);\n      this.lastUpdate++;\n      return true;\n    }\n\n    // Note: if stream is not present in a timeslice, that index in the list holds undefined\n    // This avoids repeatedly allocating new arrays for each stream, and lowers the cost of\n    // insertion/deletion, which can be a significant perf hit depending on frame rate and\n    // buffer size.\n    for (const streamName in timeslice.streams) {\n      if (!streams[streamName]) {\n        streams[streamName] = new Array(timeslices.length);\n        this.streamCount++;\n      }\n    }\n    for (const streamName in timeslice.videos) {\n      if (!videos[streamName]) {\n        videos[streamName] = new Array(timeslices.length);\n      }\n    }\n\n    const insertPosition = this._indexOf(timestamp, LEFT);\n    const timesliceAtInsertPosition = timeslices[insertPosition];\n\n    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {\n      // Same timestamp\n      if (updateType === 'COMPLETE') {\n        // Replace if it's a complete state\n        this._insertTimesliceAt(insertPosition, 1, timeslice);\n      } else {\n        // Merge if it's an incremental update (default)\n        this._mergeTimesliceAt(insertPosition, timeslice);\n      }\n    } else {\n      this._insertTimesliceAt(insertPosition, 0, timeslice);\n    }\n\n    this.lastUpdate++;\n    return true;\n  }\n\n  /**\n   * Set the current timestamp\n   * May drop timeslices that are not in range\n   * @params {number} timestamp - timestamp of the playhead\n   */\n  setCurrentTime(timestamp) {\n    if (this.bufferType === OFFSET) {\n      const {\n        options: {startOffset, endOffset}\n      } = this;\n      this.bufferStart = timestamp + startOffset;\n      this.bufferEnd = timestamp + endOffset;\n      this._pruneBuffer();\n    }\n  }\n\n  /**\n   * Override Object.prototype.valueOf\n   * This is used to trigger a selector update without creating a new XVIZStreamBuffer instance\n   */\n  valueOf() {\n    return this.lastUpdate;\n  }\n\n  /**\n   * Provide interface for video-synchronizer to test for valid gps-based time range data.\n   *\n   * @params {number} fromTime is the gps time start of data\n   * @params {number} toTime is the gps time end of data\n   * @returns {bool} If we have no data, always return true, else true is returned\n   *                 if the time range is satisfied\n   */\n  hasBuffer(fromTime, toTime) {\n    // TODO: persistent\n    if (!this.timeslices.length) {\n      return true;\n    }\n    const {start, end} = this.getLoadedTimeRange();\n    return fromTime >= start && toTime <= end;\n  }\n\n  /**\n   * Check if a timestamp is inside the desired buffer range\n   * @params {number} timestamp\n   * @returns {bool}\n   */\n  isInBufferRange(timestamp) {\n    const {bufferStart, bufferEnd, bufferType} = this;\n    if (bufferType !== UNLIMITED && Number.isFinite(bufferStart)) {\n      return timestamp >= bufferStart && timestamp <= bufferEnd;\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, no-unused-expressions */\n  _pruneBuffer() {\n    const {timeslices, streams, videos} = this;\n\n    if (timeslices.length) {\n      const startIndex = this._indexOf(this.bufferStart, LEFT);\n      const endIndex = this._indexOf(this.bufferEnd, RIGHT);\n\n      XVIZObject.prune(this.bufferStart, this.bufferEnd);\n\n      const trimStart = startIndex > 0;\n      const trimEnd = endIndex < timeslices.length;\n      if (trimStart || trimEnd) {\n        // Drop frames that are outside of the buffer\n        trimEnd && timeslices.splice(endIndex);\n        trimStart && timeslices.splice(0, startIndex);\n\n        for (const streamName in streams) {\n          const stream = streams[streamName];\n          trimEnd && stream.splice(endIndex);\n          trimStart && stream.splice(0, startIndex);\n        }\n        for (const streamName in videos) {\n          const stream = videos[streamName];\n          trimEnd && stream.splice(endIndex);\n          trimStart && stream.splice(0, startIndex);\n        }\n\n        this.lastUpdate++;\n      }\n    }\n  }\n  /* eslint-enable complexity, no-unused-expressions */\n\n  _insertPersistentSlice(persistentSlice) {\n    const {persistent, persistentStreams} = this;\n    const {timestamp, streams, links} = persistentSlice;\n    const index = findInsertPos(persistent, timestamp, LEFT);\n    const timesliceAtInsertPosition = persistent[index];\n\n    if (timesliceAtInsertPosition && timesliceAtInsertPosition.timestamp === timestamp) {\n      // merge\n      Object.assign(timesliceAtInsertPosition, persistentSlice, {\n        streams: Object.assign(timesliceAtInsertPosition.streams, streams),\n        links: Object.assign(timesliceAtInsertPosition.links, links)\n      });\n    } else {\n      // insert\n      persistent.splice(index, 0, persistentSlice);\n    }\n\n    for (const streamName in streams) {\n      if (!(streamName in persistentStreams)) {\n        persistentStreams[streamName] = true;\n        this.streamCount++;\n      }\n    }\n  }\n\n  _mergeTimesliceAt(index, timeslice) {\n    const {timeslices, streams, videos} = this;\n    const timesliceAtInsertPosition = timeslices[index];\n\n    Object.assign(timesliceAtInsertPosition, timeslice, {\n      streams: Object.assign(timesliceAtInsertPosition.streams, timeslice.streams),\n      links: Object.assign(timesliceAtInsertPosition.links, timeslice.links),\n      videos: Object.assign(timesliceAtInsertPosition.videos, timeslice.videos)\n    });\n\n    for (const streamName in timeslice.streams) {\n      const value = timeslice.streams[streamName];\n      streams[streamName][index] = value;\n    }\n    for (const streamName in timeslice.videos) {\n      videos[streamName][index] = timeslice.videos[streamName];\n    }\n  }\n\n  _insertTimesliceAt(index, deleteCount, timeslice) {\n    const {timeslices, streams, videos} = this;\n\n    timeslices.splice(index, deleteCount, timeslice);\n\n    for (const streamName in streams) {\n      streams[streamName].splice(index, deleteCount, timeslice.streams[streamName]);\n    }\n\n    for (const streamName in videos) {\n      videos[streamName].splice(index, deleteCount, timeslice.videos[streamName]);\n    }\n  }\n\n  /**\n   * Return insert position for timeslice data given a timestamp\n   * @params {number} timestamp\n   * @params {number} insertPosition - insert to the left or right of the equal element.\n   * @returns {number} index of insert position\n   */\n  _indexOf(timestamp, insertPosition = LEFT) {\n    const {timeslices} = this;\n    return findInsertPos(timeslices, timestamp, insertPosition);\n  }\n}\n"],"file":"xviz-stream-buffer.js"}