{"version":3,"sources":["../../../src/synchronizers/log-synchronizer.js"],"names":["BaseSynchronizer","assert","LogSynchronizer","constructor","logs","opts","logName","data","Array","isArray","length","logStartTime","_getTimeFromObject","index","time","_empty","Object","keys","_getTimeRangeInReverse","startTime","endTime","streams","datum","_lookupStreamDatum","links","log","startIndex","endIndex","endTimestamp","i","timestamp","object","attributes","transmission_time"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport BaseSynchronizer from './base-synchronizer';\n\nimport assert from '../utils/assert';\n\nexport default class LogSynchronizer extends BaseSynchronizer {\n  /**\n   * @classdesc\n   * The log streams are arrays of timestamped data objects, and the app\n   * will access the data object from each stream that is in the time range\n   * covering our current timestep.\n   *\n   * @class\n   * @param {Object} logs - Map of logs (arrays) with elements\n   * - Keys will be used as names of logs, and the extracted data will be\n   *   placed in a field with that name.\n   * - Each log is expected to be an array of objects.\n   * - Each log object must contain a GPS timestamp\n   *   either in the `attributes.transmission_time` or the `time` fields\n   */\n  constructor(logs = {}, opts) {\n    super(opts);\n\n    // Set up log state for all logs, so that we can move forward and back\n    this.logs = {};\n\n    for (const logName in logs) {\n      const data = logs[logName];\n      assert(Array.isArray(data) && data.length > 0, 'Invalid log data');\n      const logStartTime = this._getTimeFromObject(data[0]);\n      this.logs[logName] = {\n        data,\n        index: null, // index holds the indices to process\n        time: logStartTime // used to optimize lookup\n      };\n    }\n  }\n\n  _empty() {\n    return !this.logs || Object.keys(this.logs).length === 0;\n  }\n\n  /**\n   * Find and process stream data in the range (start, end] for process\n   * Returns a list of streams sorted by decending time\n   *\n   * Since we have all samples and can find the correct datum for every stream\n   * and only send back an array of 1 element. To do this we will apply the\n   * reverse search here, stopping when we find the entry closest to endTime.\n   *\n   * @param Number startTime - The time to start from.\n   * @param Number endTime - The time to end at.\n   */\n  _getTimeRangeInReverse(startTime, endTime) {\n    const streams = {};\n\n    // Set index based on time range for each stream\n    for (const logName in this.logs) {\n      const datum = this._lookupStreamDatum(logName, startTime, endTime);\n      if (datum) {\n        streams[logName] = datum;\n      }\n    }\n\n    return {streams: [streams], links: []};\n  }\n\n  /**\n   * @private\n   * Lookups the datum for a stream within the time range.\n   *\n   * This is a mutating function as it tracks last lookup state to\n   * optimize for sequential lookups\n   *\n   * @param {String} logName - which log to sync\n   * @param {Number} startTime - start of time to include data from\n   * @param {Number} endTime - end time to limit data within\n   * @return {Object} - returns datum for this log or null\n   */\n  _lookupStreamDatum(logName, startTime, endTime) {\n    const log = this.logs[logName];\n    assert(log, 'Invalid log');\n\n    // This is an optimization for positive time deltas (playing forward)\n    // If going backwards, just reset and perform full search.\n    if (endTime < log.time) {\n      log.time = 0;\n      log.index = null;\n    }\n\n    const startIndex = log.index || 0;\n    let endIndex = null;\n    let endTimestamp;\n\n    // invalidate\n    log.index = null;\n\n    // Find the range of indices for the given start and end time\n    for (let i = startIndex; i < log.data.length; ++i) {\n      const timestamp = this._getTimeFromObject(log.data[i]);\n      // If timestamp < startTime, sample before our target window, so don't update index\n      if (timestamp > startTime && timestamp <= endTime) {\n        // Within our target window, so update index\n        endIndex = i;\n        endTimestamp = timestamp;\n      } else if (timestamp > endTime) {\n        // Beyond our target window, so exit early\n        break;\n      }\n    }\n\n    // Found no entry\n    if (endIndex === null) {\n      return null;\n    }\n\n    log.index = endIndex;\n    log.time = endTimestamp;\n    return log.data[endIndex];\n  }\n\n  _getTimeFromObject(object) {\n    return object.time || (object.attributes && object.attributes.transmission_time);\n  }\n}\n"],"file":"log-synchronizer.js"}