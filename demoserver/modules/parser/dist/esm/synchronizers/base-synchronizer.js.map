{"version":3,"sources":["../../../src/synchronizers/base-synchronizer.js"],"names":["getXVIZConfig","xvizStats","LogSlice","memoize","assert","getCurrentLogSliceMemoized","streamFilter","lookAheadMs","linksByReverseTime","get","incrementCount","streamsByReverseTime","getCurrentFrameMemoized","logSlice","vehiclePose","trackedObjectId","postProcessFrame","getCurrentFrame","EMPTY_VEHICLE_POSE","longitude","latitude","x","y","z","BaseSynchronizer","opts","time","getLogSlice","PRIMARY_POSE_STREAM","ALLOW_MISSING_PRIMARY_POSE","defaultPose","getStream","_lastVehiclePose","Number","isFinite","offset","_empty","TIME_WINDOW","_getTimeRangeInReverse","streams","links","_streamsByReverseTime","_linksByReverseTime","startTime","endTime"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {getXVIZConfig} from '../config/xviz-config';\nimport xvizStats from '../utils/stats';\nimport LogSlice from './log-slice';\n\nimport memoize from '../utils/memoize';\nimport assert from '../utils/assert';\n\n// MEMOIZATION OF LOGSLICE CONSTRUCTOR AND GET METHOD\nconst getCurrentLogSliceMemoized = memoize(\n  (streamFilter, lookAheadMs, linksByReverseTime, ...streamsByReverseTime) => {\n    xvizStats.get('getCurrentLogSliceMemoized').incrementCount();\n    return new LogSlice(streamFilter, lookAheadMs, linksByReverseTime, streamsByReverseTime);\n  }\n);\n\nconst getCurrentFrameMemoized = memoize(\n  (logSlice, vehiclePose, trackedObjectId, postProcessFrame) => {\n    return logSlice.getCurrentFrame({vehiclePose, trackedObjectId}, postProcessFrame);\n  }\n);\n\nconst EMPTY_VEHICLE_POSE = {\n  longitude: 0,\n  latitude: 0,\n  x: 0,\n  y: 0,\n  z: 0\n};\n\n/**\n * Synchronizes log data across streams and provide the latest data\n * \"closest\" to a given timestamp within a time window.\n *\n * NOTES:\n * - logs typically use GPS time (no leap seconds)\n *   - Definition: http://www.leapsecond.com/java/gpsclock.htm\n *   - Web conversion: https://www.andrews.edu/~tzs/timeconv/timeconvert.php\n *   - Javascript conversion: https://www.npmjs.com/package/gps-time\n * - should vehicle_pose be selected based on time closes to the set time?\n *   It remains unclear what stream data is derived from which vehicle_pose\n *   due to the propogation of data thru the system.\n *\n * @param {Object[]} slices - Array of timeslices\n * - Each timeslice object must contain a GPS timestamp\n */\nexport default class BaseSynchronizer {\n  constructor(opts = {}) {\n    this.opts = opts;\n\n    this.time = 0;\n    this.lookAheadMs = 0;\n  }\n\n  // The \"frame\" contains the processed and combined data from the current log slice\n  getCurrentFrame(streamFilter, trackedObjectId) {\n    xvizStats.get('getCurrentFrame').incrementCount();\n\n    const logSlice = this.getLogSlice(streamFilter);\n    if (!logSlice) {\n      return null;\n    }\n\n    const {PRIMARY_POSE_STREAM, ALLOW_MISSING_PRIMARY_POSE} = getXVIZConfig();\n    // If a missing primary pose stream is allowed, then set the default pose\n    // value to origin.\n    const defaultPose = ALLOW_MISSING_PRIMARY_POSE ? EMPTY_VEHICLE_POSE : null;\n    const vehiclePose = logSlice.getStream(PRIMARY_POSE_STREAM, defaultPose);\n\n    if (vehiclePose !== this._lastVehiclePose) {\n      xvizStats.get('vehiclePose').incrementCount();\n      this._lastVehiclePose = vehiclePose;\n    }\n\n    return getCurrentFrameMemoized(\n      logSlice,\n      vehiclePose,\n      trackedObjectId,\n      this.opts.postProcessFrame\n    );\n  }\n\n  // @return {Number} Currently set time\n  getTime() {\n    return this.time;\n  }\n\n  /**\n   * @param {Number} time - time to synchronize the logs with\n   * @return {StreamSynchronizer} - returns itself for chaining.\n   */\n  setTime(time) {\n    this.time = time;\n    assert(Number.isFinite(this.time), 'Invalid time');\n    return this;\n  }\n\n  /**\n   * Set the lookAhead time offset.\n   *\n   * @param {Number} offset - milliseconds into the future\n   * @return {LogSynchronizer} - returns itself for chaining\n   */\n  setLookAheadTimeOffset(offset) {\n    // Change the offset time into an index.\n    this.lookAheadMs = offset;\n    return this;\n  }\n\n  // HELPER METHODS\n\n  // Get data for current time...\n  // @return {Object} - keys are stream names\n  //  values are the datum from each stream that best matches the current time.\n  getLogSlice(streamFilter) {\n    if (this._empty()) {\n      return null;\n    }\n\n    // Find the right timeslices\n    const {TIME_WINDOW} = getXVIZConfig();\n    const {streams, links} = this._getTimeRangeInReverse(this.time - TIME_WINDOW, this.time);\n    this._streamsByReverseTime = streams;\n    this._linksByReverseTime = links;\n    xvizStats.get('geometry-refresh').incrementCount();\n\n    return getCurrentLogSliceMemoized(\n      streamFilter,\n      this.lookAheadMs,\n      this._linksByReverseTime,\n      ...this._streamsByReverseTime\n    );\n  }\n\n  // PROTECTED API - DEFINED BY DERIVED CLASES\n\n  empty() {\n    assert(false);\n  }\n\n  /**\n   * Find and process stream data in the range (start, end] for process\n   * Returns a list of streams sorted by descending time\n   * Since we have all samples and can find the exact datum for the stream i\n   * there is no \"range\" of samples to process and the reverse ordering does not apply.\n   * @param Number startTime - The time to start from.\n   * @param Number endTime - The time to end at.\n   */\n  _getTimeRangeInReverse(startTime, endTime) {\n    assert(false);\n  }\n}\n"],"file":"base-synchronizer.js"}