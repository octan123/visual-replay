{"version":3,"sources":["../../../src/parsers/filter-vertices.js"],"names":["Vector3","getXVIZConfig","filterVertices","vertices","THRESHOLD","pathDistanceThreshold","isFlatArray","Number","isFinite","vertexCount","length","newVertices","index","lastEmittedVertex","lastEmittedIndex","i","v","getPointAtIndex","shouldAddVert","distance","lastVertex","point","slice"],"mappings":"AAcA,SAAQA,OAAR,QAAsB,SAAtB;AAEA,SAAQC,aAAR,QAA4B,uBAA5B;AAKA,OAAO,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;AACvC,MAAMC,SAAS,GAAGH,aAAa,GAAGI,qBAAlC;AACA,MAAMC,WAAW,GAAGC,MAAM,CAACC,QAAP,CAAgBL,QAAQ,CAAC,CAAD,CAAxB,CAApB;AACA,MAAMM,WAAW,GAAGH,WAAW,GAAGH,QAAQ,CAACO,MAAT,GAAkB,CAArB,GAAyBP,QAAQ,CAACO,MAAjE;AAEA,MAAMC,WAAW,GAAG,EAApB;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAIC,gBAAgB,GAAG,CAAC,CAAxB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,WAApB,EAAiCM,CAAC,EAAlC,EAAsC;AACpC,QAAMC,CAAC,GAAGC,eAAe,CAACd,QAAD,EAAWY,CAAX,EAAcT,WAAd,CAAzB;AACA,QAAMY,aAAa,GAAGJ,gBAAgB,KAAK,CAAC,CAAtB,IAA2BD,iBAAiB,CAACM,QAAlB,CAA2BH,CAA3B,IAAgCZ,SAAjF;;AACA,QAAIc,aAAJ,EAAmB;AACjBP,MAAAA,WAAW,CAACC,KAAK,EAAN,CAAX,GAAuBI,CAAC,CAAC,CAAD,CAAxB;AACAL,MAAAA,WAAW,CAACC,KAAK,EAAN,CAAX,GAAuBI,CAAC,CAAC,CAAD,CAAxB;AACAL,MAAAA,WAAW,CAACC,KAAK,EAAN,CAAX,GAAuBI,CAAC,CAAC,CAAD,CAAxB;AACAH,MAAAA,iBAAiB,GAAG,IAAIb,OAAJ,CAAYgB,CAAC,CAAC,CAAD,CAAb,EAAkBA,CAAC,CAAC,CAAD,CAAnB,EAAwBA,CAAC,CAAC,CAAD,CAAzB,CAApB;AACAF,MAAAA,gBAAgB,GAAGC,CAAnB;AACD;AACF;;AAGD,MAAID,gBAAgB,KAAKL,WAAW,GAAG,CAAvC,EAA0C;AACxC,QAAMW,UAAU,GAAGH,eAAe,CAACd,QAAD,EAAWM,WAAW,GAAG,CAAzB,EAA4BH,WAA5B,CAAlC;AACAM,IAAAA,KAAK,IAAI,CAAT;AACAD,IAAAA,WAAW,CAACC,KAAK,EAAN,CAAX,GAAuBQ,UAAU,CAAC,CAAD,CAAjC;AACAT,IAAAA,WAAW,CAACC,KAAK,EAAN,CAAX,GAAuBQ,UAAU,CAAC,CAAD,CAAjC;AACAT,IAAAA,WAAW,CAACC,KAAK,EAAN,CAAX,GAAuBQ,UAAU,CAAC,CAAD,CAAjC;AACD;;AAED,SAAOT,WAAP;AACD;;AAED,SAASM,eAAT,CAAyBd,QAAzB,EAAmCY,CAAnC,EAA2D;AAAA,MAArBT,WAAqB,uEAAP,KAAO;AACzD,MAAIe,KAAK,GAAG,IAAZ;;AACA,MAAIf,WAAJ,EAAiB;AACfe,IAAAA,KAAK,GAAGlB,QAAQ,CAACmB,KAAT,CAAeP,CAAC,GAAG,CAAnB,EAAsBA,CAAC,GAAG,CAAJ,GAAQ,CAA9B,CAAR;AACD,GAFD,MAEO;AACLM,IAAAA,KAAK,GAAGlB,QAAQ,CAACY,CAAD,CAAhB;AACD;;AAEDM,EAAAA,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAL,IAAY,CAAvB;AACA,SAAOA,KAAP;AACD","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Vector3} from 'math.gl';\n\nimport {getXVIZConfig} from '../config/xviz-config';\n\n// filter out identical vertices from a list\n// Ensure points at least a certain distance away from each other\n// This reduces data size and works around an issue in the deck.gl PathLayer\nexport function filterVertices(vertices) {\n  const THRESHOLD = getXVIZConfig().pathDistanceThreshold;\n  const isFlatArray = Number.isFinite(vertices[0]);\n  const vertexCount = isFlatArray ? vertices.length / 3 : vertices.length;\n\n  const newVertices = [];\n  let index = 0;\n  let lastEmittedVertex = null;\n  let lastEmittedIndex = -1;\n  for (let i = 0; i < vertexCount; i++) {\n    const v = getPointAtIndex(vertices, i, isFlatArray);\n    const shouldAddVert = lastEmittedIndex === -1 || lastEmittedVertex.distance(v) > THRESHOLD;\n    if (shouldAddVert) {\n      newVertices[index++] = v[0];\n      newVertices[index++] = v[1];\n      newVertices[index++] = v[2];\n      lastEmittedVertex = new Vector3(v[0], v[1], v[2]);\n      lastEmittedIndex = i;\n    }\n  }\n\n  // Make sure we always emit the last vertex\n  if (lastEmittedIndex !== vertexCount - 1) {\n    const lastVertex = getPointAtIndex(vertices, vertexCount - 1, isFlatArray);\n    index -= 3;\n    newVertices[index++] = lastVertex[0];\n    newVertices[index++] = lastVertex[1];\n    newVertices[index++] = lastVertex[2];\n  }\n\n  return newVertices;\n}\n\nfunction getPointAtIndex(vertices, i, isFlatArray = false) {\n  let point = null;\n  if (isFlatArray) {\n    point = vertices.slice(i * 3, i * 3 + 3);\n  } else {\n    point = vertices[i];\n  }\n\n  point[2] = point[2] || 0;\n  return point;\n}\n"],"file":"filter-vertices.js"}